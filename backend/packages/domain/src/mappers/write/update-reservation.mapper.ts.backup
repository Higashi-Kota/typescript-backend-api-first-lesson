/**
 * Update Reservation Mapper (Write Operation)
 * API Request -> Domain Model -> Database Entity
 */

import { match } from 'ts-pattern'
import type {
  Reservation,
  ReservationChanges,
  ReservationId,
  ReservationOperationResult,
  UpdateReservationRequest,
  UpdateReservationRequestWithReset,
} from '../../models/reservation'
import type { ValidationError } from '../../shared/errors'
import type { Result } from '../../shared/result'
import { err, ok } from '../../shared/result'

// Type aliases for clarity
type ApiUpdateRequest = UpdateReservationRequest
type ApiUpdateRequestWithReset = UpdateReservationRequestWithReset
type DomainReservation = Reservation
type DbReservationUpdate = {
  startTime?: string
  endTime?: string
  staffId?: string
  serviceId?: string
  status?: string
  totalAmount?: number
  depositAmount?: number
  isPaid?: boolean
  paymentMethod?: string | null
  notes?: string | null
  reminderSent?: boolean
  updatedAt: Date
  updatedBy?: string | null
}

/**
 * Map API Update Request to Domain Model (partial update)
 */
export const mapUpdateReservationApiToDomain = (
  request: ApiUpdateRequest,
  existingReservation: DomainReservation
): Result<Partial<DomainReservation>, ValidationError[]> => {
  try {
    const updates: Partial<DomainReservation> = {}

    if (request.startTime !== undefined) {
      updates.startTime = request.startTime
    }

    if (request.endTime !== undefined) {
      updates.endTime = request.endTime
    }

    if (request.staffId !== undefined) {
      updates.staffId = request.staffId as any
    }

    if (request.serviceId !== undefined) {
      updates.serviceId = request.serviceId as any
    }

    if (request.status !== undefined) {
      updates.status = request.status
    }

    if (request.totalAmount !== undefined) {
      updates.totalAmount = request.totalAmount
    }

    if (request.depositAmount !== undefined) {
      updates.depositAmount = request.depositAmount
    }

    if (request.isPaid !== undefined) {
      updates.isPaid = request.isPaid
    }

    if (request.paymentMethod !== undefined) {
      updates.paymentMethod = request.paymentMethod
    }

    if (request.notes !== undefined) {
      updates.notes = request.notes
    }

    if (request.reminderSent !== undefined) {
      updates.reminderSent = request.reminderSent
    }

    updates.updatedAt = new Date().toISOString()

    // Validate time logic if times are being updated
    const errors: ValidationError[] = []

    if (updates.startTime || updates.endTime) {
      const startTime = updates.startTime || existingReservation.startTime
      const endTime = updates.endTime || existingReservation.endTime
      const start = new Date(startTime)
      const end = new Date(endTime)

      if (start >= end) {
        errors.push({
          field: 'endTime',
          message: 'End time must be after start time',
        })
      }

      if (start < new Date()) {
        errors.push({
          field: 'startTime',
          message: 'Cannot update reservation to a past time',
        })
      }
    }

    if (updates.totalAmount !== undefined && updates.totalAmount < 0) {
      errors.push({
        field: 'totalAmount',
        message: 'Total amount cannot be negative',
      })
    }

    if (updates.depositAmount !== undefined && updates.depositAmount < 0) {
      errors.push({
        field: 'depositAmount',
        message: 'Deposit amount cannot be negative',
      })
    }

    if (errors.length > 0) {
      return err(errors)
    }

    return ok(updates)
  } catch (error) {
    return err([{ field: 'general', message: `Mapping error: ${error}` }])
  }
}

/**
 * Map API Update Request with Reset to Domain Model
 * Handles null values for field resets
 */
export const mapUpdateReservationWithResetApiToDomain = (
  request: ApiUpdateRequestWithReset,
  existingReservation: DomainReservation
): Result<Partial<DomainReservation>, ValidationError[]> => {
  try {
    const updates: Partial<DomainReservation> = {}

    if (request.startTime !== undefined) {
      updates.startTime = request.startTime
    }

    if (request.endTime !== undefined) {
      updates.endTime = request.endTime
    }

    if (request.staffId !== undefined) {
      updates.staffId = request.staffId as any
    }

    if (request.serviceId !== undefined) {
      updates.serviceId = request.serviceId as any
    }

    if (request.status !== undefined) {
      updates.status = request.status
    }

    if (request.totalAmount !== undefined) {
      updates.totalAmount = request.totalAmount
    }

    if (request.depositAmount !== undefined) {
      updates.depositAmount = request.depositAmount
    }

    if (request.isPaid !== undefined) {
      updates.isPaid = request.isPaid
    }

    // Handle nullable fields (can be reset to null)
    if (request.paymentMethod !== undefined) {
      updates.paymentMethod =
        request.paymentMethod === null ? undefined : request.paymentMethod
    }

    if (request.notes !== undefined) {
      updates.notes = request.notes === null ? undefined : request.notes
    }

    if (request.reminderSent !== undefined) {
      updates.reminderSent = request.reminderSent
    }

    updates.updatedAt = new Date().toISOString()

    // Validate (similar to regular update)
    const errors: ValidationError[] = []

    if (updates.startTime || updates.endTime) {
      const startTime = updates.startTime || existingReservation.startTime
      const endTime = updates.endTime || existingReservation.endTime
      const start = new Date(startTime)
      const end = new Date(endTime)

      if (start >= end) {
        errors.push({
          field: 'endTime',
          message: 'End time must be after start time',
        })
      }

      if (start < new Date()) {
        errors.push({
          field: 'startTime',
          message: 'Cannot update reservation to a past time',
        })
      }
    }

    if (updates.totalAmount !== undefined && updates.totalAmount < 0) {
      errors.push({
        field: 'totalAmount',
        message: 'Total amount cannot be negative',
      })
    }

    if (updates.depositAmount !== undefined && updates.depositAmount < 0) {
      errors.push({
        field: 'depositAmount',
        message: 'Deposit amount cannot be negative',
      })
    }

    if (errors.length > 0) {
      return err(errors)
    }

    return ok(updates)
  } catch (error) {
    return err([{ field: 'general', message: `Mapping error: ${error}` }])
  }
}

/**
 * Map Domain Model updates to Database Update
 */
export const mapUpdateReservationDomainToDb = (
  updates: Partial<DomainReservation>,
  updatedBy?: string
): DbReservationUpdate => {
  const dbUpdate: DbReservationUpdate = {
    updatedAt: new Date(updates.updatedAt || new Date().toISOString()),
    updatedBy: updatedBy ?? null,
  }

  if (updates.startTime !== undefined) {
    dbUpdate.startTime = updates.startTime
  }

  if (updates.endTime !== undefined) {
    dbUpdate.endTime = updates.endTime
  }

  if (updates.staffId !== undefined) {
    dbUpdate.staffId = updates.staffId
  }

  if (updates.serviceId !== undefined) {
    dbUpdate.serviceId = updates.serviceId
  }

  if (updates.status !== undefined) {
    dbUpdate.status = updates.status
  }

  if (updates.totalAmount !== undefined) {
    dbUpdate.totalAmount = updates.totalAmount
  }

  if (updates.depositAmount !== undefined) {
    dbUpdate.depositAmount = updates.depositAmount
  }

  if (updates.isPaid !== undefined) {
    dbUpdate.isPaid = updates.isPaid
  }

  if (updates.paymentMethod !== undefined) {
    dbUpdate.paymentMethod = updates.paymentMethod ?? null
  }

  if (updates.notes !== undefined) {
    dbUpdate.notes = updates.notes ?? null
  }

  if (updates.reminderSent !== undefined) {
    dbUpdate.reminderSent = updates.reminderSent
  }

  return dbUpdate
}

/**
 * Complete flow: API → Domain → DB
 */
export const updateReservationWriteFlow = (
  _reservationId: ReservationId,
  request: ApiUpdateRequest | ApiUpdateRequestWithReset,
  existingReservation: DomainReservation,
  isResetRequest = false
): Result<DbReservationUpdate, ReservationOperationResult> => {
  // Step 1: Map API to Domain
  const domainResult = isResetRequest
    ? mapUpdateReservationWithResetApiToDomain(
        request as ApiUpdateRequestWithReset,
        existingReservation
      )
    : mapUpdateReservationApiToDomain(request as ApiUpdateRequest, existingReservation)

  if (domainResult.type === 'err') {
    return err({ type: 'validation_failed', errors: domainResult.error })
  }

  // Step 2: Map Domain to DB
  try {
    const dbUpdate = mapUpdateReservationDomainToDb(domainResult.value)
    return ok(dbUpdate)
  } catch (error) {
    return err({
      type: 'error',
      error: { type: 'system', message: `Failed to map to database format: ${error}` },
    })
  }
}

/**
 * Track changes for audit
 */
export const trackReservationChanges = (
  oldReservation: DomainReservation,
  newReservation: Partial<DomainReservation>
): ReservationChanges => {
  const changes: ReservationChanges = {}

  if (
    newReservation.startTime &&
    newReservation.startTime !== oldReservation.startTime
  ) {
    changes.startTime = {
      from: oldReservation.startTime,
      to: newReservation.startTime,
    }
  }

  if (newReservation.endTime && newReservation.endTime !== oldReservation.endTime) {
    changes.endTime = {
      from: oldReservation.endTime,
      to: newReservation.endTime,
    }
  }

  if (newReservation.staffId && newReservation.staffId !== oldReservation.staffId) {
    changes.staffId = {
      from: oldReservation.staffId,
      to: newReservation.staffId,
    }
  }

  if (
    newReservation.serviceId &&
    newReservation.serviceId !== oldReservation.serviceId
  ) {
    changes.serviceId = {
      from: oldReservation.serviceId,
      to: newReservation.serviceId,
    }
  }

  if (newReservation.status && newReservation.status !== oldReservation.status) {
    changes.status = { from: oldReservation.status, to: newReservation.status }
  }

  if (
    newReservation.totalAmount !== undefined &&
    newReservation.totalAmount !== oldReservation.totalAmount
  ) {
    changes.totalAmount = {
      from: oldReservation.totalAmount,
      to: newReservation.totalAmount,
    }
  }

  if (newReservation.notes !== oldReservation.notes) {
    changes.notes = { from: oldReservation.notes, to: newReservation.notes }
  }

  return changes
}

/**
 * Handle update operation result
 */
export const handleUpdateReservationResult = (
  result: ReservationOperationResult
): string => {
  return match(result)
    .with(
      { type: 'updated' },
      ({ reservation, changes }) =>
        `Reservation ${reservation.id} updated successfully. Changes: ${changes.join(', ')}`
    )
    .with(
      { type: 'validation_failed' },
      ({ errors }) =>
        `Validation failed: ${errors.map((e) => `${e.field}: ${e.message}`).join(', ')}`
    )
    .with(
      { type: 'not_found' },
      ({ reservationId }) => `Reservation with ID ${reservationId} not found`
    )
    .with(
      { type: 'time_slot_unavailable' },
      ({ startTime, endTime }) =>
        `Time slot ${startTime} to ${endTime} is not available`
    )
    .with(
      { type: 'staff_unavailable' },
      ({ staffId, time }) =>
        `Staff ${staffId} is not available at ${time}`
    )
    .with(
      { type: 'conflict' },
      ({ message }) => `Conflict: ${message}`
    )
    .with({ type: 'error' }, ({ error }) =>
      match(error)
        .with({ type: 'system' }, ({ message }) => `System error: ${message}`)
        .with({ type: 'validation' }, ({ errors }) =>
          `Validation errors: ${errors.map((e) => e.message).join(', ')}`
        )
        .with({ type: 'businessRule' }, ({ message }) => `Business rule: ${message}`)
        .otherwise(() => 'Unknown error')
    )
    .otherwise(() => 'Unknown error occurred')
}