/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Beauty Salon API
 * Comprehensive REST API for managing beauty salon operations including salons, staff, services, customers, reservations, bookings, treatments, payments, inventory, and access control. Built with TypeSpec for type-safe API-first development.
 * OpenAPI spec version: 2.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  CustomerCrudBatchGet200,
  CustomerCrudBulkCreate207,
  CustomerCrudBulkCreateBody,
  CustomerCrudBulkDelete207,
  CustomerCrudBulkDeleteBody,
  CustomerCrudBulkUpdate207,
  CustomerCrudBulkUpdateBody,
  CustomerCrudCreate201,
  CustomerCrudDeleteParams,
  CustomerCrudExport202,
  CustomerCrudExportBody,
  CustomerCrudGet200,
  CustomerCrudGetHistory200,
  CustomerCrudGetHistoryParams,
  CustomerCrudGetParams,
  CustomerCrudGetVersion200,
  CustomerCrudList200,
  CustomerCrudListParams,
  CustomerCrudPatch200,
  CustomerCrudPatchParams,
  CustomerCrudRestore200,
  CustomerCrudSearch200,
  CustomerCrudSearchParams,
  CustomerCrudUpdate200,
  CustomerOperationsAddLoyaltyPoints200,
  CustomerOperationsAddLoyaltyPointsBody,
  CustomerOperationsExportDataParams,
  CustomerOperationsGetBookings200,
  CustomerOperationsGetBookingsParams,
  CustomerOperationsGetProfile200,
  CustomerOperationsGetReservations200,
  CustomerOperationsGetReservationsParams,
  CustomerOperationsGetStatistics200,
  CustomerOperationsGetStatisticsParams,
  CustomerOperationsMerge200,
  CustomerOperationsMergeBody,
  CustomerOperationsRequestDeletion202,
  CustomerOperationsRequestDeletionBody,
  CustomerOperationsUpdatePreferences200,
  ModelsBatchGetRequest,
  ModelsCreateCustomerRequest,
  ModelsCustomerId,
  ModelsCustomerPreferencesUpdateRequest,
  ModelsProblemDetails,
  ModelsUpdateCustomerRequest,
  ModelsUpdateCustomerRequestUpdate,
} from '../../models'

import { customInstance } from '../../../../../io/src/libs/fetcher/fetcher'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÇÑ„Éï„Ç£„É´„Çø„ÉºÊù°‰ª∂„ÇíÊåáÂÆö„Åó„Å¶ÂØæË±°„É™„ÇΩ„Éº„Çπ„Çí‰∏ÄË¶ßÂèñÂæó„Åó„Åæ„Åô„ÄÇÊ•≠ÂãôÁîªÈù¢„ÅÆ„É™„Çπ„ÉàË°®Á§∫„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ
 * @summary List {Name} resources
 */
export type customerCrudListResponse200 = {
  data: CustomerCrudList200
  status: 200
}

export type customerCrudListResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudListResponseComposite =
  | customerCrudListResponse200
  | customerCrudListResponse400

export type customerCrudListResponse = customerCrudListResponseComposite & {
  headers: Headers
}

export const getCustomerCrudListUrl = (params?: CustomerCrudListParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/?${stringifiedParams}`
    : `/api/v1/customers/`
}

export const customerCrudList = async (
  params?: CustomerCrudListParams,
  options?: RequestInit
): Promise<customerCrudListResponse> => {
  return customInstance<customerCrudListResponse>(
    getCustomerCrudListUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerCrudListQueryKey = (
  params?: CustomerCrudListParams
) => {
  return [`/api/v1/customers/`, ...(params ? [params] : [])] as const
}

export const getCustomerCrudListQueryOptions = <
  TData = Awaited<ReturnType<typeof customerCrudList>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCustomerCrudListQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerCrudList>>
  > = ({ signal }) => customerCrudList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof customerCrudList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerCrudListQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudList>>
>
export type CustomerCrudListQueryError = ModelsProblemDetails

export function useCustomerCrudList<
  TData = Awaited<ReturnType<typeof customerCrudList>>,
  TError = ModelsProblemDetails,
>(
  params: undefined | CustomerCrudListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudList>>,
          TError,
          Awaited<ReturnType<typeof customerCrudList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudList<
  TData = Awaited<ReturnType<typeof customerCrudList>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudList>>,
          TError,
          Awaited<ReturnType<typeof customerCrudList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudList<
  TData = Awaited<ReturnType<typeof customerCrudList>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List {Name} resources
 */

export function useCustomerCrudList<
  TData = Awaited<ReturnType<typeof customerCrudList>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerCrudListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Êñ∞Ë¶è„É™„ÇΩ„Éº„Çπ„Çí‰ΩúÊàê„Åó„ÄÅ‰ΩúÊàêÊôÇ„ÅÆ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÇÑÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÁµêÊûú„ÇíËøîÂç¥„Åó„Åæ„Åô„ÄÇ
 * @summary Create new {Name}
 */
export type customerCrudCreateResponse201 = {
  data: CustomerCrudCreate201
  status: 201
}

export type customerCrudCreateResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudCreateResponseComposite =
  | customerCrudCreateResponse201
  | customerCrudCreateResponse400

export type customerCrudCreateResponse = customerCrudCreateResponseComposite & {
  headers: Headers
}

export const getCustomerCrudCreateUrl = () => {
  return `/api/v1/customers/`
}

export const customerCrudCreate = async (
  modelsCreateCustomerRequest: ModelsCreateCustomerRequest,
  options?: RequestInit
): Promise<customerCrudCreateResponse> => {
  return customInstance<customerCrudCreateResponse>(
    getCustomerCrudCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsCreateCustomerRequest),
    }
  )
}

export const getCustomerCrudCreateMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudCreate>>,
    TError,
    { data: ModelsCreateCustomerRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudCreate>>,
  TError,
  { data: ModelsCreateCustomerRequest },
  TContext
> => {
  const mutationKey = ['customerCrudCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudCreate>>,
    { data: ModelsCreateCustomerRequest }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudCreate>>
>
export type CustomerCrudCreateMutationBody = ModelsCreateCustomerRequest
export type CustomerCrudCreateMutationError = ModelsProblemDetails

/**
 * @summary Create new {Name}
 */
export const useCustomerCrudCreate = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudCreate>>,
      TError,
      { data: ModelsCreateCustomerRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudCreate>>,
  TError,
  { data: ModelsCreateCustomerRequest },
  TContext
> => {
  const mutationOptions = getCustomerCrudCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Ë§áÊï∞ID„Çí„Åæ„Å®„ÇÅ„Å¶ÂèñÂæó„Åó„ÄÅ‰∏ÄË¶ßÁîªÈù¢„ÅÆÈÅÖÂª∂Ë™≠„ÅøËæº„Åø„ÇÑÂ§ñÈÉ®ÈÄ£Êê∫„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ
 * @summary Batch get {Name} resources
 */
export type customerCrudBatchGetResponse200 = {
  data: CustomerCrudBatchGet200
  status: 200
}

export type customerCrudBatchGetResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudBatchGetResponseComposite =
  | customerCrudBatchGetResponse200
  | customerCrudBatchGetResponse400

export type customerCrudBatchGetResponse =
  customerCrudBatchGetResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudBatchGetUrl = () => {
  return `/api/v1/customers/batch/get`
}

export const customerCrudBatchGet = async (
  modelsBatchGetRequest: ModelsBatchGetRequest,
  options?: RequestInit
): Promise<customerCrudBatchGetResponse> => {
  return customInstance<customerCrudBatchGetResponse>(
    getCustomerCrudBatchGetUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsBatchGetRequest),
    }
  )
}

export const getCustomerCrudBatchGetMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudBatchGet>>,
    TError,
    { data: ModelsBatchGetRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudBatchGet>>,
  TError,
  { data: ModelsBatchGetRequest },
  TContext
> => {
  const mutationKey = ['customerCrudBatchGet']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudBatchGet>>,
    { data: ModelsBatchGetRequest }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudBatchGet(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudBatchGetMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudBatchGet>>
>
export type CustomerCrudBatchGetMutationBody = ModelsBatchGetRequest
export type CustomerCrudBatchGetMutationError = ModelsProblemDetails

/**
 * @summary Batch get {Name} resources
 */
export const useCustomerCrudBatchGet = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudBatchGet>>,
      TError,
      { data: ModelsBatchGetRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudBatchGet>>,
  TError,
  { data: ModelsBatchGetRequest },
  TContext
> => {
  const mutationOptions = getCustomerCrudBatchGetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Ë§áÊï∞„É™„ÇΩ„Éº„Çπ„Çí‰∏ÄÊã¨‰ΩúÊàê„Åó„ÄÅÁµêÊûú„ÇíÊàêÂäü„ÉªÂ§±Êïó„Å´ÂàÜ„Åë„Å¶ËøîÂç¥„Åó„Åæ„Åô„ÄÇ
 * @summary Bulk create {Name} resources
 */
export type customerCrudBulkCreateResponse207 = {
  data: CustomerCrudBulkCreate207
  status: 207
}

export type customerCrudBulkCreateResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudBulkCreateResponseComposite =
  | customerCrudBulkCreateResponse207
  | customerCrudBulkCreateResponse400

export type customerCrudBulkCreateResponse =
  customerCrudBulkCreateResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudBulkCreateUrl = () => {
  return `/api/v1/customers/bulk`
}

export const customerCrudBulkCreate = async (
  customerCrudBulkCreateBody: CustomerCrudBulkCreateBody,
  options?: RequestInit
): Promise<customerCrudBulkCreateResponse> => {
  return customInstance<customerCrudBulkCreateResponse>(
    getCustomerCrudBulkCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerCrudBulkCreateBody),
    }
  )
}

export const getCustomerCrudBulkCreateMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudBulkCreate>>,
    TError,
    { data: CustomerCrudBulkCreateBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudBulkCreate>>,
  TError,
  { data: CustomerCrudBulkCreateBody },
  TContext
> => {
  const mutationKey = ['customerCrudBulkCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudBulkCreate>>,
    { data: CustomerCrudBulkCreateBody }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudBulkCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudBulkCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudBulkCreate>>
>
export type CustomerCrudBulkCreateMutationBody = CustomerCrudBulkCreateBody
export type CustomerCrudBulkCreateMutationError = ModelsProblemDetails

/**
 * @summary Bulk create {Name} resources
 */
export const useCustomerCrudBulkCreate = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudBulkCreate>>,
      TError,
      { data: CustomerCrudBulkCreateBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudBulkCreate>>,
  TError,
  { data: CustomerCrudBulkCreateBody },
  TContext
> => {
  const mutationOptions = getCustomerCrudBulkCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Ë§áÊï∞„É™„ÇΩ„Éº„Çπ„ÅÆÊõ¥Êñ∞„Çí„Åæ„Å®„ÇÅ„Å¶Âèó„Åë‰ªò„Åë„ÄÅ„Éê„Éº„Ç∏„Éß„É≥Êï¥ÂêàÊÄß„Çí‰øù„Å°„Å™„Åå„ÇâÂá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ
 * @summary Bulk update {Name} resources
 */
export type customerCrudBulkUpdateResponse207 = {
  data: CustomerCrudBulkUpdate207
  status: 207
}

export type customerCrudBulkUpdateResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudBulkUpdateResponseComposite =
  | customerCrudBulkUpdateResponse207
  | customerCrudBulkUpdateResponse400

export type customerCrudBulkUpdateResponse =
  customerCrudBulkUpdateResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudBulkUpdateUrl = () => {
  return `/api/v1/customers/bulk`
}

export const customerCrudBulkUpdate = async (
  customerCrudBulkUpdateBody: CustomerCrudBulkUpdateBody,
  options?: RequestInit
): Promise<customerCrudBulkUpdateResponse> => {
  return customInstance<customerCrudBulkUpdateResponse>(
    getCustomerCrudBulkUpdateUrl(),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerCrudBulkUpdateBody),
    }
  )
}

export const getCustomerCrudBulkUpdateMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudBulkUpdate>>,
    TError,
    { data: CustomerCrudBulkUpdateBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudBulkUpdate>>,
  TError,
  { data: CustomerCrudBulkUpdateBody },
  TContext
> => {
  const mutationKey = ['customerCrudBulkUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudBulkUpdate>>,
    { data: CustomerCrudBulkUpdateBody }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudBulkUpdate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudBulkUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudBulkUpdate>>
>
export type CustomerCrudBulkUpdateMutationBody = CustomerCrudBulkUpdateBody
export type CustomerCrudBulkUpdateMutationError = ModelsProblemDetails

/**
 * @summary Bulk update {Name} resources
 */
export const useCustomerCrudBulkUpdate = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudBulkUpdate>>,
      TError,
      { data: CustomerCrudBulkUpdateBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudBulkUpdate>>,
  TError,
  { data: CustomerCrudBulkUpdateBody },
  TContext
> => {
  const mutationOptions = getCustomerCrudBulkUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Ë§áÊï∞„É™„ÇΩ„Éº„Çπ„Çí‰∏ÄÊã¨ÂâäÈô§„Åó„ÄÅÊàêÂäüÂèØÂê¶„Åî„Å®„ÅÆÁµêÊûú„ÇíËøîÂç¥„Åó„Åæ„Åô„ÄÇ
 * @summary Bulk delete {Name} resources
 */
export type customerCrudBulkDeleteResponse207 = {
  data: CustomerCrudBulkDelete207
  status: 207
}

export type customerCrudBulkDeleteResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudBulkDeleteResponseComposite =
  | customerCrudBulkDeleteResponse207
  | customerCrudBulkDeleteResponse400

export type customerCrudBulkDeleteResponse =
  customerCrudBulkDeleteResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudBulkDeleteUrl = () => {
  return `/api/v1/customers/bulk`
}

export const customerCrudBulkDelete = async (
  customerCrudBulkDeleteBody: CustomerCrudBulkDeleteBody,
  options?: RequestInit
): Promise<customerCrudBulkDeleteResponse> => {
  return customInstance<customerCrudBulkDeleteResponse>(
    getCustomerCrudBulkDeleteUrl(),
    {
      ...options,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerCrudBulkDeleteBody),
    }
  )
}

export const getCustomerCrudBulkDeleteMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudBulkDelete>>,
    TError,
    { data: CustomerCrudBulkDeleteBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudBulkDelete>>,
  TError,
  { data: CustomerCrudBulkDeleteBody },
  TContext
> => {
  const mutationKey = ['customerCrudBulkDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudBulkDelete>>,
    { data: CustomerCrudBulkDeleteBody }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudBulkDelete(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudBulkDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudBulkDelete>>
>
export type CustomerCrudBulkDeleteMutationBody = CustomerCrudBulkDeleteBody
export type CustomerCrudBulkDeleteMutationError = ModelsProblemDetails

/**
 * @summary Bulk delete {Name} resources
 */
export const useCustomerCrudBulkDelete = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudBulkDelete>>,
      TError,
      { data: CustomerCrudBulkDeleteBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudBulkDelete>>,
  TError,
  { data: CustomerCrudBulkDeleteBody },
  TContext
> => {
  const mutationOptions = getCustomerCrudBulkDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Ê§úÁ¥¢ÁµêÊûú„ÇíÊåáÂÆöÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„ÄÅÂ∏≥Á•®Âá∫Âäõ„ÇÑÂ§ñÈÉ®ÂÖ±Êúâ„Å´Ê¥ªÁî®„Åó„Åæ„Åô„ÄÇ
 * @summary Export {Name} search results
 */
export type customerCrudExportResponse202 = {
  data: CustomerCrudExport202
  status: 202
}

export type customerCrudExportResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudExportResponseComposite =
  | customerCrudExportResponse202
  | customerCrudExportResponse400

export type customerCrudExportResponse = customerCrudExportResponseComposite & {
  headers: Headers
}

export const getCustomerCrudExportUrl = () => {
  return `/api/v1/customers/export`
}

export const customerCrudExport = async (
  customerCrudExportBody: CustomerCrudExportBody,
  options?: RequestInit
): Promise<customerCrudExportResponse> => {
  return customInstance<customerCrudExportResponse>(
    getCustomerCrudExportUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerCrudExportBody),
    }
  )
}

export const getCustomerCrudExportMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudExport>>,
    TError,
    { data: CustomerCrudExportBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudExport>>,
  TError,
  { data: CustomerCrudExportBody },
  TContext
> => {
  const mutationKey = ['customerCrudExport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudExport>>,
    { data: CustomerCrudExportBody }
  > = (props) => {
    const { data } = props ?? {}

    return customerCrudExport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudExport>>
>
export type CustomerCrudExportMutationBody = CustomerCrudExportBody
export type CustomerCrudExportMutationError = ModelsProblemDetails

/**
 * @summary Export {Name} search results
 */
export const useCustomerCrudExport = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudExport>>,
      TError,
      { data: CustomerCrudExportBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudExport>>,
  TError,
  { data: CustomerCrudExportBody },
  TContext
> => {
  const mutationOptions = getCustomerCrudExportMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * ÈáçË§áÁôªÈå≤„Åï„Çå„ÅüÈ°ßÂÆ¢„É¨„Ç≥„Éº„Éâ„ÇíÁµ±Âêà„Åó„ÄÅÂ±•Ê≠¥„ÇÑ„Éù„Ç§„É≥„Éà„Çí‰∏ÄÊú¨Âåñ„Åó„Åæ„Åô„ÄÇ
 * @summary Merge customer records
 */
export type customerOperationsMergeResponse200 = {
  data: CustomerOperationsMerge200
  status: 200
}

export type customerOperationsMergeResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerOperationsMergeResponseComposite =
  | customerOperationsMergeResponse200
  | customerOperationsMergeResponse400

export type customerOperationsMergeResponse =
  customerOperationsMergeResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsMergeUrl = () => {
  return `/api/v1/customers/merge`
}

export const customerOperationsMerge = async (
  customerOperationsMergeBody: CustomerOperationsMergeBody,
  options?: RequestInit
): Promise<customerOperationsMergeResponse> => {
  return customInstance<customerOperationsMergeResponse>(
    getCustomerOperationsMergeUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerOperationsMergeBody),
    }
  )
}

export const getCustomerOperationsMergeMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerOperationsMerge>>,
    TError,
    { data: CustomerOperationsMergeBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerOperationsMerge>>,
  TError,
  { data: CustomerOperationsMergeBody },
  TContext
> => {
  const mutationKey = ['customerOperationsMerge']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerOperationsMerge>>,
    { data: CustomerOperationsMergeBody }
  > = (props) => {
    const { data } = props ?? {}

    return customerOperationsMerge(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerOperationsMergeMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsMerge>>
>
export type CustomerOperationsMergeMutationBody = CustomerOperationsMergeBody
export type CustomerOperationsMergeMutationError = ModelsProblemDetails

/**
 * @summary Merge customer records
 */
export const useCustomerOperationsMerge = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerOperationsMerge>>,
      TError,
      { data: CustomerOperationsMergeBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerOperationsMerge>>,
  TError,
  { data: CustomerOperationsMergeBody },
  TContext
> => {
  const mutationOptions = getCustomerOperationsMergeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * „Éï„Ç°„Çª„ÉÉ„Éà„ÇÑË§áÂêàÊù°‰ª∂„ÇíÂà©Áî®„Åó„Å¶„É™„ÇΩ„Éº„Çπ„ÇíÊ§úÁ¥¢„Åó„ÄÅÁµêÊûú„Å®Áµ±Ë®àÊÉÖÂ†±„ÇíËøîÂç¥„Åó„Åæ„Åô„ÄÇ
 * @summary Search {Name} resources
 */
export type customerCrudSearchResponse200 = {
  data: CustomerCrudSearch200
  status: 200
}

export type customerCrudSearchResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudSearchResponseComposite =
  | customerCrudSearchResponse200
  | customerCrudSearchResponse400

export type customerCrudSearchResponse = customerCrudSearchResponseComposite & {
  headers: Headers
}

export const getCustomerCrudSearchUrl = (params?: CustomerCrudSearchParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/search?${stringifiedParams}`
    : `/api/v1/customers/search`
}

export const customerCrudSearch = async (
  params?: CustomerCrudSearchParams,
  options?: RequestInit
): Promise<customerCrudSearchResponse> => {
  return customInstance<customerCrudSearchResponse>(
    getCustomerCrudSearchUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerCrudSearchQueryKey = (
  params?: CustomerCrudSearchParams
) => {
  return [`/api/v1/customers/search`, ...(params ? [params] : [])] as const
}

export const getCustomerCrudSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof customerCrudSearch>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudSearch>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getCustomerCrudSearchQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerCrudSearch>>
  > = ({ signal }) => customerCrudSearch(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof customerCrudSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerCrudSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudSearch>>
>
export type CustomerCrudSearchQueryError = ModelsProblemDetails

export function useCustomerCrudSearch<
  TData = Awaited<ReturnType<typeof customerCrudSearch>>,
  TError = ModelsProblemDetails,
>(
  params: undefined | CustomerCrudSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudSearch>>,
          TError,
          Awaited<ReturnType<typeof customerCrudSearch>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudSearch<
  TData = Awaited<ReturnType<typeof customerCrudSearch>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudSearch>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudSearch>>,
          TError,
          Awaited<ReturnType<typeof customerCrudSearch>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudSearch<
  TData = Awaited<ReturnType<typeof customerCrudSearch>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudSearch>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Search {Name} resources
 */

export function useCustomerCrudSearch<
  TData = Awaited<ReturnType<typeof customerCrudSearch>>,
  TError = ModelsProblemDetails,
>(
  params?: CustomerCrudSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudSearch>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerCrudSearchQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ID„ÇíÊåáÂÆö„Åó„Å¶Âçò‰∏Ä„É™„ÇΩ„Éº„Çπ„ÇíÂèñÂæó„Åó„ÄÅË©≥Á¥∞Ë°®Á§∫„ÇÑÁ∑®ÈõÜ„Éï„Ç©„Éº„É†„ÅÆÂàùÊúüÂÄ§„Å´‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ
 * @summary Get {Name} by ID
 */
export type customerCrudGetResponse200 = {
  data: CustomerCrudGet200
  status: 200
}

export type customerCrudGetResponse304 = {
  data: void
  status: 304
}

export type customerCrudGetResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerCrudGetResponseComposite =
  | customerCrudGetResponse200
  | customerCrudGetResponse304
  | customerCrudGetResponse401

export type customerCrudGetResponse = customerCrudGetResponseComposite & {
  headers: Headers
}

export const getCustomerCrudGetUrl = (
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}?${stringifiedParams}`
    : `/api/v1/customers/${id}`
}

export const customerCrudGet = async (
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams,
  options?: RequestInit
): Promise<customerCrudGetResponse> => {
  return customInstance<customerCrudGetResponse>(
    getCustomerCrudGetUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerCrudGetQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams
) => {
  return [`/api/v1/customers/${id}`, ...(params ? [params] : [])] as const
}

export const getCustomerCrudGetQueryOptions = <
  TData = Awaited<ReturnType<typeof customerCrudGet>>,
  TError = void | ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getCustomerCrudGetQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof customerCrudGet>>> = ({
    signal,
  }) => customerCrudGet(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerCrudGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerCrudGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudGet>>
>
export type CustomerCrudGetQueryError = void | ModelsProblemDetails

export function useCustomerCrudGet<
  TData = Awaited<ReturnType<typeof customerCrudGet>>,
  TError = void | ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerCrudGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGet>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGet<
  TData = Awaited<ReturnType<typeof customerCrudGet>>,
  TError = void | ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGet>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGet<
  TData = Awaited<ReturnType<typeof customerCrudGet>>,
  TError = void | ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get {Name} by ID
 */

export function useCustomerCrudGet<
  TData = Awaited<ReturnType<typeof customerCrudGet>>,
  TError = void | ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerCrudGetQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Êó¢Â≠ò„É™„ÇΩ„Éº„Çπ„ÇíÂÖ®È†ÖÁõÆÊõ¥Êñ∞„Åó„ÄÅÊúÄÊñ∞Áä∂ÊÖã„Å®„Éê„Éº„Ç∏„Éß„É≥ÊÉÖÂ†±„ÇíËøîÂç¥„Åó„Åæ„Åô„ÄÇ
 * @summary Update {Name}
 */
export type customerCrudUpdateResponse200 = {
  data: CustomerCrudUpdate200
  status: 200
}

export type customerCrudUpdateResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudUpdateResponseComposite =
  | customerCrudUpdateResponse200
  | customerCrudUpdateResponse400

export type customerCrudUpdateResponse = customerCrudUpdateResponseComposite & {
  headers: Headers
}

export const getCustomerCrudUpdateUrl = (id: ModelsCustomerId) => {
  return `/api/v1/customers/${id}`
}

export const customerCrudUpdate = async (
  id: ModelsCustomerId,
  modelsUpdateCustomerRequest: ModelsUpdateCustomerRequest,
  options?: RequestInit
): Promise<customerCrudUpdateResponse> => {
  return customInstance<customerCrudUpdateResponse>(
    getCustomerCrudUpdateUrl(id),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsUpdateCustomerRequest),
    }
  )
}

export const getCustomerCrudUpdateMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudUpdate>>,
    TError,
    { id: ModelsCustomerId; data: ModelsUpdateCustomerRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudUpdate>>,
  TError,
  { id: ModelsCustomerId; data: ModelsUpdateCustomerRequest },
  TContext
> => {
  const mutationKey = ['customerCrudUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudUpdate>>,
    { id: ModelsCustomerId; data: ModelsUpdateCustomerRequest }
  > = (props) => {
    const { id, data } = props ?? {}

    return customerCrudUpdate(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudUpdate>>
>
export type CustomerCrudUpdateMutationBody = ModelsUpdateCustomerRequest
export type CustomerCrudUpdateMutationError = ModelsProblemDetails

/**
 * @summary Update {Name}
 */
export const useCustomerCrudUpdate = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudUpdate>>,
      TError,
      { id: ModelsCustomerId; data: ModelsUpdateCustomerRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudUpdate>>,
  TError,
  { id: ModelsCustomerId; data: ModelsUpdateCustomerRequest },
  TContext
> => {
  const mutationOptions = getCustomerCrudUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * ÂøÖË¶Å„Å™„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Åø„ÇíÈÉ®ÂàÜÊõ¥Êñ∞„Åó„ÄÅÂ§âÊõ¥Â∑ÆÂàÜ„ÇíÂäπÁéáÁöÑ„Å´ÂèçÊò†„Åó„Åæ„Åô„ÄÇ
 * @summary Partially update {Name}
 */
export type customerCrudPatchResponse200 = {
  data: CustomerCrudPatch200
  status: 200
}

export type customerCrudPatchResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerCrudPatchResponseComposite =
  | customerCrudPatchResponse200
  | customerCrudPatchResponse400

export type customerCrudPatchResponse = customerCrudPatchResponseComposite & {
  headers: Headers
}

export const getCustomerCrudPatchUrl = (
  id: ModelsCustomerId,
  params?: CustomerCrudPatchParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}?${stringifiedParams}`
    : `/api/v1/customers/${id}`
}

export const customerCrudPatch = async (
  id: ModelsCustomerId,
  modelsUpdateCustomerRequestUpdate: ModelsUpdateCustomerRequestUpdate,
  params?: CustomerCrudPatchParams,
  options?: RequestInit
): Promise<customerCrudPatchResponse> => {
  return customInstance<customerCrudPatchResponse>(
    getCustomerCrudPatchUrl(id, params),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsUpdateCustomerRequestUpdate),
    }
  )
}

export const getCustomerCrudPatchMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudPatch>>,
    TError,
    {
      id: ModelsCustomerId
      data: ModelsUpdateCustomerRequestUpdate
      params?: CustomerCrudPatchParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudPatch>>,
  TError,
  {
    id: ModelsCustomerId
    data: ModelsUpdateCustomerRequestUpdate
    params?: CustomerCrudPatchParams
  },
  TContext
> => {
  const mutationKey = ['customerCrudPatch']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudPatch>>,
    {
      id: ModelsCustomerId
      data: ModelsUpdateCustomerRequestUpdate
      params?: CustomerCrudPatchParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return customerCrudPatch(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudPatch>>
>
export type CustomerCrudPatchMutationBody = ModelsUpdateCustomerRequestUpdate
export type CustomerCrudPatchMutationError = ModelsProblemDetails

/**
 * @summary Partially update {Name}
 */
export const useCustomerCrudPatch = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudPatch>>,
      TError,
      {
        id: ModelsCustomerId
        data: ModelsUpdateCustomerRequestUpdate
        params?: CustomerCrudPatchParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudPatch>>,
  TError,
  {
    id: ModelsCustomerId
    data: ModelsUpdateCustomerRequestUpdate
    params?: CustomerCrudPatchParams
  },
  TContext
> => {
  const mutationOptions = getCustomerCrudPatchMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * „É™„ÇΩ„Éº„Çπ„ÇíÂâäÈô§„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë´ñÁêÜÂâäÈô§„ÅãÁâ©ÁêÜÂâäÈô§„Åã„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ
 * @summary Delete {Name}
 */
export type customerCrudDeleteResponse204 = {
  data: void
  status: 204
}

export type customerCrudDeleteResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerCrudDeleteResponseComposite =
  | customerCrudDeleteResponse204
  | customerCrudDeleteResponse401

export type customerCrudDeleteResponse = customerCrudDeleteResponseComposite & {
  headers: Headers
}

export const getCustomerCrudDeleteUrl = (
  id: ModelsCustomerId,
  params?: CustomerCrudDeleteParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}?${stringifiedParams}`
    : `/api/v1/customers/${id}`
}

export const customerCrudDelete = async (
  id: ModelsCustomerId,
  params?: CustomerCrudDeleteParams,
  options?: RequestInit
): Promise<customerCrudDeleteResponse> => {
  return customInstance<customerCrudDeleteResponse>(
    getCustomerCrudDeleteUrl(id, params),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

export const getCustomerCrudDeleteMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudDelete>>,
    TError,
    { id: ModelsCustomerId; params?: CustomerCrudDeleteParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudDelete>>,
  TError,
  { id: ModelsCustomerId; params?: CustomerCrudDeleteParams },
  TContext
> => {
  const mutationKey = ['customerCrudDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudDelete>>,
    { id: ModelsCustomerId; params?: CustomerCrudDeleteParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return customerCrudDelete(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudDelete>>
>

export type CustomerCrudDeleteMutationError = ModelsProblemDetails

/**
 * @summary Delete {Name}
 */
export const useCustomerCrudDelete = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudDelete>>,
      TError,
      { id: ModelsCustomerId; params?: CustomerCrudDeleteParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudDelete>>,
  TError,
  { id: ModelsCustomerId; params?: CustomerCrudDeleteParams },
  TContext
> => {
  const mutationOptions = getCustomerCrudDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * È°ßÂÆ¢Âçò‰Ωç„ÅÆ‰∫àÁ¥Ñ„Éë„ÉÉ„Ç±„Éº„Ç∏ÊÉÖÂ†±„ÇíÂèñÂæó„Åó„ÄÅË§áÊï∞ÊñΩË°ì„ÇíË∑®„ÅÑ„Å†Âà©Áî®Áä∂Ê≥Å„ÇíÊääÊè°„Åó„Åæ„Åô„ÄÇ
 * @summary Get customer bookings
 */
export type customerOperationsGetBookingsResponse200 = {
  data: CustomerOperationsGetBookings200
  status: 200
}

export type customerOperationsGetBookingsResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerOperationsGetBookingsResponseComposite =
  | customerOperationsGetBookingsResponse200
  | customerOperationsGetBookingsResponse401

export type customerOperationsGetBookingsResponse =
  customerOperationsGetBookingsResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsGetBookingsUrl = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}/bookings?${stringifiedParams}`
    : `/api/v1/customers/${id}/bookings`
}

export const customerOperationsGetBookings = async (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams,
  options?: RequestInit
): Promise<customerOperationsGetBookingsResponse> => {
  return customInstance<customerOperationsGetBookingsResponse>(
    getCustomerOperationsGetBookingsUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerOperationsGetBookingsQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams
) => {
  return [
    `/api/v1/customers/${id}/bookings`,
    ...(params ? [params] : []),
  ] as const
}

export const getCustomerOperationsGetBookingsQueryOptions = <
  TData = Awaited<ReturnType<typeof customerOperationsGetBookings>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetBookings>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getCustomerOperationsGetBookingsQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerOperationsGetBookings>>
  > = ({ signal }) =>
    customerOperationsGetBookings(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerOperationsGetBookings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerOperationsGetBookingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsGetBookings>>
>
export type CustomerOperationsGetBookingsQueryError = ModelsProblemDetails

export function useCustomerOperationsGetBookings<
  TData = Awaited<ReturnType<typeof customerOperationsGetBookings>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerOperationsGetBookingsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetBookings>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetBookings>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetBookings>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetBookings<
  TData = Awaited<ReturnType<typeof customerOperationsGetBookings>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetBookings>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetBookings>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetBookings>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetBookings<
  TData = Awaited<ReturnType<typeof customerOperationsGetBookings>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetBookings>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get customer bookings
 */

export function useCustomerOperationsGetBookings<
  TData = Awaited<ReturnType<typeof customerOperationsGetBookings>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetBookingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetBookings>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerOperationsGetBookingsQueryOptions(
    id,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * È°ßÂÆ¢„Åã„Çâ„ÅÆÂâäÈô§Ë¶ÅË´ã„ÇíÂèó„Åë‰ªò„Åë„ÄÅË¶èÂà∂„Å´Ê≤ø„Å£„ÅüÊ∂àÂéª„Éï„É≠„Éº„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ
 * @summary Request customer data deletion
 */
export type customerOperationsRequestDeletionResponse202 = {
  data: CustomerOperationsRequestDeletion202
  status: 202
}

export type customerOperationsRequestDeletionResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerOperationsRequestDeletionResponseComposite =
  | customerOperationsRequestDeletionResponse202
  | customerOperationsRequestDeletionResponse400

export type customerOperationsRequestDeletionResponse =
  customerOperationsRequestDeletionResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsRequestDeletionUrl = (
  id: ModelsCustomerId
) => {
  return `/api/v1/customers/${id}/deletion-request`
}

export const customerOperationsRequestDeletion = async (
  id: ModelsCustomerId,
  customerOperationsRequestDeletionBody: CustomerOperationsRequestDeletionBody,
  options?: RequestInit
): Promise<customerOperationsRequestDeletionResponse> => {
  return customInstance<customerOperationsRequestDeletionResponse>(
    getCustomerOperationsRequestDeletionUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerOperationsRequestDeletionBody),
    }
  )
}

export const getCustomerOperationsRequestDeletionMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerOperationsRequestDeletion>>,
    TError,
    { id: ModelsCustomerId; data: CustomerOperationsRequestDeletionBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerOperationsRequestDeletion>>,
  TError,
  { id: ModelsCustomerId; data: CustomerOperationsRequestDeletionBody },
  TContext
> => {
  const mutationKey = ['customerOperationsRequestDeletion']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerOperationsRequestDeletion>>,
    { id: ModelsCustomerId; data: CustomerOperationsRequestDeletionBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return customerOperationsRequestDeletion(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerOperationsRequestDeletionMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsRequestDeletion>>
>
export type CustomerOperationsRequestDeletionMutationBody =
  CustomerOperationsRequestDeletionBody
export type CustomerOperationsRequestDeletionMutationError =
  ModelsProblemDetails

/**
 * @summary Request customer data deletion
 */
export const useCustomerOperationsRequestDeletion = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerOperationsRequestDeletion>>,
      TError,
      { id: ModelsCustomerId; data: CustomerOperationsRequestDeletionBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerOperationsRequestDeletion>>,
  TError,
  { id: ModelsCustomerId; data: CustomerOperationsRequestDeletionBody },
  TContext
> => {
  const mutationOptions =
    getCustomerOperationsRequestDeletionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * È°ßÂÆ¢„ÅåËá™Ë∫´„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó„Åß„Åç„Çã„Çà„ÅÜ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„ÄÅGDPRÁ≠â„ÅÆÂÄã‰∫∫ÊÉÖÂ†±Ë¶èÂà∂„Å´ÂØæÂøú„Åó„Åæ„Åô„ÄÇ
 * @summary Export customer data
 */
export type customerOperationsExportDataResponse200 = {
  data: Blob
  status: 200
}

export type customerOperationsExportDataResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerOperationsExportDataResponseComposite =
  | customerOperationsExportDataResponse200
  | customerOperationsExportDataResponse401

export type customerOperationsExportDataResponse =
  customerOperationsExportDataResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsExportDataUrl = (
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}/export?${stringifiedParams}`
    : `/api/v1/customers/${id}/export`
}

export const customerOperationsExportData = async (
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams,
  options?: RequestInit
): Promise<customerOperationsExportDataResponse> => {
  return customInstance<customerOperationsExportDataResponse>(
    getCustomerOperationsExportDataUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerOperationsExportDataQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams
) => {
  return [
    `/api/v1/customers/${id}/export`,
    ...(params ? [params] : []),
  ] as const
}

export const getCustomerOperationsExportDataQueryOptions = <
  TData = Awaited<ReturnType<typeof customerOperationsExportData>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsExportData>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getCustomerOperationsExportDataQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerOperationsExportData>>
  > = ({ signal }) =>
    customerOperationsExportData(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerOperationsExportData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerOperationsExportDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsExportData>>
>
export type CustomerOperationsExportDataQueryError = ModelsProblemDetails

export function useCustomerOperationsExportData<
  TData = Awaited<ReturnType<typeof customerOperationsExportData>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerOperationsExportDataParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsExportData>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsExportData>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsExportData>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsExportData<
  TData = Awaited<ReturnType<typeof customerOperationsExportData>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsExportData>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsExportData>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsExportData>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsExportData<
  TData = Awaited<ReturnType<typeof customerOperationsExportData>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsExportData>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Export customer data
 */

export function useCustomerOperationsExportData<
  TData = Awaited<ReturnType<typeof customerOperationsExportData>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsExportDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsExportData>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerOperationsExportDataQueryOptions(
    id,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ÂØæË±°„É™„ÇΩ„Éº„Çπ„ÅÆÁõ£ÊüªÂ±•Ê≠¥„ÇíÂèñÂæó„Åó„ÄÅÂ§âÊõ¥ËÄÖ„ÇÑÂ§âÊõ¥ÂÜÖÂÆπ„ÇíËøΩË∑°„Åó„Åæ„Åô„ÄÇ
 * @summary Get {Name} audit history
 */
export type customerCrudGetHistoryResponse200 = {
  data: CustomerCrudGetHistory200
  status: 200
}

export type customerCrudGetHistoryResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerCrudGetHistoryResponseComposite =
  | customerCrudGetHistoryResponse200
  | customerCrudGetHistoryResponse401

export type customerCrudGetHistoryResponse =
  customerCrudGetHistoryResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudGetHistoryUrl = (
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}/history?${stringifiedParams}`
    : `/api/v1/customers/${id}/history`
}

export const customerCrudGetHistory = async (
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams,
  options?: RequestInit
): Promise<customerCrudGetHistoryResponse> => {
  return customInstance<customerCrudGetHistoryResponse>(
    getCustomerCrudGetHistoryUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerCrudGetHistoryQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams
) => {
  return [
    `/api/v1/customers/${id}/history`,
    ...(params ? [params] : []),
  ] as const
}

export const getCustomerCrudGetHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof customerCrudGetHistory>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetHistory>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getCustomerCrudGetHistoryQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerCrudGetHistory>>
  > = ({ signal }) =>
    customerCrudGetHistory(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerCrudGetHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerCrudGetHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudGetHistory>>
>
export type CustomerCrudGetHistoryQueryError = ModelsProblemDetails

export function useCustomerCrudGetHistory<
  TData = Awaited<ReturnType<typeof customerCrudGetHistory>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerCrudGetHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGetHistory>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGetHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGetHistory<
  TData = Awaited<ReturnType<typeof customerCrudGetHistory>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGetHistory>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGetHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGetHistory<
  TData = Awaited<ReturnType<typeof customerCrudGetHistory>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetHistory>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get {Name} audit history
 */

export function useCustomerCrudGetHistory<
  TData = Awaited<ReturnType<typeof customerCrudGetHistory>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerCrudGetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetHistory>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerCrudGetHistoryQueryOptions(
    id,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Êù•Â∫ó„ÇÑ„Ç≠„É£„É≥„Éö„Éº„É≥„Å´Âøú„Åò„Å¶„É≠„Ç§„É§„É´„ÉÜ„Ç£„Éù„Ç§„É≥„Éà„ÇíÂä†ÁÆó„Åó„ÄÅÈ°ßÂÆ¢Á∂≠ÊåÅ„Çí‰øÉÈÄ≤„Åó„Åæ„Åô„ÄÇ
 * @summary Add loyalty points
 */
export type customerOperationsAddLoyaltyPointsResponse200 = {
  data: CustomerOperationsAddLoyaltyPoints200
  status: 200
}

export type customerOperationsAddLoyaltyPointsResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerOperationsAddLoyaltyPointsResponseComposite =
  | customerOperationsAddLoyaltyPointsResponse200
  | customerOperationsAddLoyaltyPointsResponse400

export type customerOperationsAddLoyaltyPointsResponse =
  customerOperationsAddLoyaltyPointsResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsAddLoyaltyPointsUrl = (
  id: ModelsCustomerId
) => {
  return `/api/v1/customers/${id}/loyalty-points`
}

export const customerOperationsAddLoyaltyPoints = async (
  id: ModelsCustomerId,
  customerOperationsAddLoyaltyPointsBody: CustomerOperationsAddLoyaltyPointsBody,
  options?: RequestInit
): Promise<customerOperationsAddLoyaltyPointsResponse> => {
  return customInstance<customerOperationsAddLoyaltyPointsResponse>(
    getCustomerOperationsAddLoyaltyPointsUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(customerOperationsAddLoyaltyPointsBody),
    }
  )
}

export const getCustomerOperationsAddLoyaltyPointsMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>,
    TError,
    { id: ModelsCustomerId; data: CustomerOperationsAddLoyaltyPointsBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>,
  TError,
  { id: ModelsCustomerId; data: CustomerOperationsAddLoyaltyPointsBody },
  TContext
> => {
  const mutationKey = ['customerOperationsAddLoyaltyPoints']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>,
    { id: ModelsCustomerId; data: CustomerOperationsAddLoyaltyPointsBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return customerOperationsAddLoyaltyPoints(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerOperationsAddLoyaltyPointsMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>
>
export type CustomerOperationsAddLoyaltyPointsMutationBody =
  CustomerOperationsAddLoyaltyPointsBody
export type CustomerOperationsAddLoyaltyPointsMutationError =
  ModelsProblemDetails

/**
 * @summary Add loyalty points
 */
export const useCustomerOperationsAddLoyaltyPoints = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>,
      TError,
      { id: ModelsCustomerId; data: CustomerOperationsAddLoyaltyPointsBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerOperationsAddLoyaltyPoints>>,
  TError,
  { id: ModelsCustomerId; data: CustomerOperationsAddLoyaltyPointsBody },
  TContext
> => {
  const mutationOptions =
    getCustomerOperationsAddLoyaltyPointsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * È°ßÂÆ¢„ÅÆÊñΩË°ìÂ•Ω„Åø„ÇÑÈÄ£Áµ°ÊâãÊÆµ„Å™„Å©„ÅÆÂ∏åÊúõË®≠ÂÆö„ÇíÊõ¥Êñ∞„Åó„ÄÅ„Éë„Éº„ÇΩ„Éä„É©„Ç§„Ç∫„Åï„Çå„ÅüÊèêÊ°à„Å´ÂèçÊò†„Åó„Åæ„Åô„ÄÇ
 * @summary Update customer preferences
 */
export type customerOperationsUpdatePreferencesResponse200 = {
  data: CustomerOperationsUpdatePreferences200
  status: 200
}

export type customerOperationsUpdatePreferencesResponse400 = {
  data: ModelsProblemDetails
  status: 400
}

export type customerOperationsUpdatePreferencesResponseComposite =
  | customerOperationsUpdatePreferencesResponse200
  | customerOperationsUpdatePreferencesResponse400

export type customerOperationsUpdatePreferencesResponse =
  customerOperationsUpdatePreferencesResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsUpdatePreferencesUrl = (
  id: ModelsCustomerId
) => {
  return `/api/v1/customers/${id}/preferences`
}

export const customerOperationsUpdatePreferences = async (
  id: ModelsCustomerId,
  modelsCustomerPreferencesUpdateRequest: ModelsCustomerPreferencesUpdateRequest,
  options?: RequestInit
): Promise<customerOperationsUpdatePreferencesResponse> => {
  return customInstance<customerOperationsUpdatePreferencesResponse>(
    getCustomerOperationsUpdatePreferencesUrl(id),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsCustomerPreferencesUpdateRequest),
    }
  )
}

export const getCustomerOperationsUpdatePreferencesMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>,
    TError,
    { id: ModelsCustomerId; data: ModelsCustomerPreferencesUpdateRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>,
  TError,
  { id: ModelsCustomerId; data: ModelsCustomerPreferencesUpdateRequest },
  TContext
> => {
  const mutationKey = ['customerOperationsUpdatePreferences']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>,
    { id: ModelsCustomerId; data: ModelsCustomerPreferencesUpdateRequest }
  > = (props) => {
    const { id, data } = props ?? {}

    return customerOperationsUpdatePreferences(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerOperationsUpdatePreferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>
>
export type CustomerOperationsUpdatePreferencesMutationBody =
  ModelsCustomerPreferencesUpdateRequest
export type CustomerOperationsUpdatePreferencesMutationError =
  ModelsProblemDetails

/**
 * @summary Update customer preferences
 */
export const useCustomerOperationsUpdatePreferences = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>,
      TError,
      { id: ModelsCustomerId; data: ModelsCustomerPreferencesUpdateRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerOperationsUpdatePreferences>>,
  TError,
  { id: ModelsCustomerId; data: ModelsCustomerPreferencesUpdateRequest },
  TContext
> => {
  const mutationOptions =
    getCustomerOperationsUpdatePreferencesMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * È°ßÂÆ¢„ÅÆÂü∫Êú¨ÊÉÖÂ†±„Å´Âä†„Åà„ÄÅÂóúÂ•Ω„ÇÑÈÄ£Áµ°ÂÖà„Å™„Å©Êã°ÂºµÊÉÖÂ†±„ÇíÂèñÂæó„Åó„ÄÅ„Éë„Éº„ÇΩ„Éä„É©„Ç§„Ç∫ÂØæÂøú„Å´Ê¥ª„Åã„Åó„Åæ„Åô„ÄÇ
 * @summary Get customer profile
 */
export type customerOperationsGetProfileResponse200 = {
  data: CustomerOperationsGetProfile200
  status: 200
}

export type customerOperationsGetProfileResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerOperationsGetProfileResponseComposite =
  | customerOperationsGetProfileResponse200
  | customerOperationsGetProfileResponse401

export type customerOperationsGetProfileResponse =
  customerOperationsGetProfileResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsGetProfileUrl = (id: ModelsCustomerId) => {
  return `/api/v1/customers/${id}/profile`
}

export const customerOperationsGetProfile = async (
  id: ModelsCustomerId,
  options?: RequestInit
): Promise<customerOperationsGetProfileResponse> => {
  return customInstance<customerOperationsGetProfileResponse>(
    getCustomerOperationsGetProfileUrl(id),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerOperationsGetProfileQueryKey = (
  id: ModelsCustomerId
) => {
  return [`/api/v1/customers/${id}/profile`] as const
}

export const getCustomerOperationsGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof customerOperationsGetProfile>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetProfile>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getCustomerOperationsGetProfileQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerOperationsGetProfile>>
  > = ({ signal }) =>
    customerOperationsGetProfile(id, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerOperationsGetProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerOperationsGetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsGetProfile>>
>
export type CustomerOperationsGetProfileQueryError = ModelsProblemDetails

export function useCustomerOperationsGetProfile<
  TData = Awaited<ReturnType<typeof customerOperationsGetProfile>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetProfile>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetProfile>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetProfile<
  TData = Awaited<ReturnType<typeof customerOperationsGetProfile>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetProfile>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetProfile>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetProfile<
  TData = Awaited<ReturnType<typeof customerOperationsGetProfile>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetProfile>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get customer profile
 */

export function useCustomerOperationsGetProfile<
  TData = Awaited<ReturnType<typeof customerOperationsGetProfile>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetProfile>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerOperationsGetProfileQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * È°ßÂÆ¢„Åå‰øùÊåÅ„Åô„Çã‰∫àÁ¥ÑÂ±•Ê≠¥„ÇíÂèñÂæó„Åó„ÄÅÊù•Â∫ó‰∫àÂÆö„ÇÑÈÅéÂéªÊñΩË°ì„ÅÆÁ¢∫Ë™ç„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ
 * @summary Get customer reservations
 */
export type customerOperationsGetReservationsResponse200 = {
  data: CustomerOperationsGetReservations200
  status: 200
}

export type customerOperationsGetReservationsResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerOperationsGetReservationsResponseComposite =
  | customerOperationsGetReservationsResponse200
  | customerOperationsGetReservationsResponse401

export type customerOperationsGetReservationsResponse =
  customerOperationsGetReservationsResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsGetReservationsUrl = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}/reservations?${stringifiedParams}`
    : `/api/v1/customers/${id}/reservations`
}

export const customerOperationsGetReservations = async (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams,
  options?: RequestInit
): Promise<customerOperationsGetReservationsResponse> => {
  return customInstance<customerOperationsGetReservationsResponse>(
    getCustomerOperationsGetReservationsUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerOperationsGetReservationsQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams
) => {
  return [
    `/api/v1/customers/${id}/reservations`,
    ...(params ? [params] : []),
  ] as const
}

export const getCustomerOperationsGetReservationsQueryOptions = <
  TData = Awaited<ReturnType<typeof customerOperationsGetReservations>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetReservations>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getCustomerOperationsGetReservationsQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerOperationsGetReservations>>
  > = ({ signal }) =>
    customerOperationsGetReservations(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerOperationsGetReservations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerOperationsGetReservationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsGetReservations>>
>
export type CustomerOperationsGetReservationsQueryError = ModelsProblemDetails

export function useCustomerOperationsGetReservations<
  TData = Awaited<ReturnType<typeof customerOperationsGetReservations>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerOperationsGetReservationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetReservations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetReservations>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetReservations>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetReservations<
  TData = Awaited<ReturnType<typeof customerOperationsGetReservations>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetReservations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetReservations>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetReservations>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetReservations<
  TData = Awaited<ReturnType<typeof customerOperationsGetReservations>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetReservations>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get customer reservations
 */

export function useCustomerOperationsGetReservations<
  TData = Awaited<ReturnType<typeof customerOperationsGetReservations>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetReservationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetReservations>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerOperationsGetReservationsQueryOptions(
    id,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ÂâäÈô§Ê∏à„Åø„É™„ÇΩ„Éº„Çπ„ÇíÂæ©ÂÖÉ„Åó„ÄÅË™§ÂâäÈô§„Å∏„ÅÆËøÖÈÄü„Å™„É™„Ç´„Éê„É™„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ
 * @summary Restore deleted {Name}
 */
export type customerCrudRestoreResponse200 = {
  data: CustomerCrudRestore200
  status: 200
}

export type customerCrudRestoreResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerCrudRestoreResponseComposite =
  | customerCrudRestoreResponse200
  | customerCrudRestoreResponse401

export type customerCrudRestoreResponse =
  customerCrudRestoreResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudRestoreUrl = (id: ModelsCustomerId) => {
  return `/api/v1/customers/${id}/restore`
}

export const customerCrudRestore = async (
  id: ModelsCustomerId,
  options?: RequestInit
): Promise<customerCrudRestoreResponse> => {
  return customInstance<customerCrudRestoreResponse>(
    getCustomerCrudRestoreUrl(id),
    {
      ...options,
      method: 'POST',
    }
  )
}

export const getCustomerCrudRestoreMutationOptions = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof customerCrudRestore>>,
    TError,
    { id: ModelsCustomerId },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof customerCrudRestore>>,
  TError,
  { id: ModelsCustomerId },
  TContext
> => {
  const mutationKey = ['customerCrudRestore']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof customerCrudRestore>>,
    { id: ModelsCustomerId }
  > = (props) => {
    const { id } = props ?? {}

    return customerCrudRestore(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CustomerCrudRestoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudRestore>>
>

export type CustomerCrudRestoreMutationError = ModelsProblemDetails

/**
 * @summary Restore deleted {Name}
 */
export const useCustomerCrudRestore = <
  TError = ModelsProblemDetails,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof customerCrudRestore>>,
      TError,
      { id: ModelsCustomerId },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof customerCrudRestore>>,
  TError,
  { id: ModelsCustomerId },
  TContext
> => {
  const mutationOptions = getCustomerCrudRestoreMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Êù•Â∫óÈ†ªÂ∫¶„ÇÑÂ£≤‰∏äË≤¢ÁåÆÂ∫¶„Å™„Å©È°ßÂÆ¢ÊåáÊ®ô„ÇíÈõÜË®à„Åó„ÄÅ„Çª„Ç∞„É°„É≥„ÉàÊñΩÁ≠ñ„ÇÑVIPÂà§ÂÆö„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ
 * @summary Get customer statistics
 */
export type customerOperationsGetStatisticsResponse200 = {
  data: CustomerOperationsGetStatistics200
  status: 200
}

export type customerOperationsGetStatisticsResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerOperationsGetStatisticsResponseComposite =
  | customerOperationsGetStatisticsResponse200
  | customerOperationsGetStatisticsResponse401

export type customerOperationsGetStatisticsResponse =
  customerOperationsGetStatisticsResponseComposite & {
    headers: Headers
  }

export const getCustomerOperationsGetStatisticsUrl = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/customers/${id}/statistics?${stringifiedParams}`
    : `/api/v1/customers/${id}/statistics`
}

export const customerOperationsGetStatistics = async (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams,
  options?: RequestInit
): Promise<customerOperationsGetStatisticsResponse> => {
  return customInstance<customerOperationsGetStatisticsResponse>(
    getCustomerOperationsGetStatisticsUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerOperationsGetStatisticsQueryKey = (
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams
) => {
  return [
    `/api/v1/customers/${id}/statistics`,
    ...(params ? [params] : []),
  ] as const
}

export const getCustomerOperationsGetStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getCustomerOperationsGetStatisticsQueryKey(id, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerOperationsGetStatistics>>
  > = ({ signal }) =>
    customerOperationsGetStatistics(id, params, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerOperationsGetStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerOperationsGetStatistics>>
>
export type CustomerOperationsGetStatisticsQueryError = ModelsProblemDetails

export function useCustomerOperationsGetStatistics<
  TData = Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params: undefined | CustomerOperationsGetStatisticsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetStatistics>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetStatistics<
  TData = Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
          TError,
          Awaited<ReturnType<typeof customerOperationsGetStatistics>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerOperationsGetStatistics<
  TData = Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get customer statistics
 */

export function useCustomerOperationsGetStatistics<
  TData = Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  params?: CustomerOperationsGetStatisticsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerOperationsGetStatistics>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerOperationsGetStatisticsQueryOptions(
    id,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * ÊåáÂÆö„Åó„Åü„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„É™„ÇΩ„Éº„ÇπÁä∂ÊÖã„ÇíÂèñÂæó„Åó„ÄÅÈÅéÂéªÁä∂ÊÖã„ÅÆÁ¢∫Ë™ç„ÇÑÊØîËºÉ„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ
 * @summary Get {Name} version
 */
export type customerCrudGetVersionResponse200 = {
  data: CustomerCrudGetVersion200
  status: 200
}

export type customerCrudGetVersionResponse401 = {
  data: ModelsProblemDetails
  status: 401
}

export type customerCrudGetVersionResponseComposite =
  | customerCrudGetVersionResponse200
  | customerCrudGetVersionResponse401

export type customerCrudGetVersionResponse =
  customerCrudGetVersionResponseComposite & {
    headers: Headers
  }

export const getCustomerCrudGetVersionUrl = (
  id: ModelsCustomerId,
  version: number
) => {
  return `/api/v1/customers/${id}/versions/${version}`
}

export const customerCrudGetVersion = async (
  id: ModelsCustomerId,
  version: number,
  options?: RequestInit
): Promise<customerCrudGetVersionResponse> => {
  return customInstance<customerCrudGetVersionResponse>(
    getCustomerCrudGetVersionUrl(id, version),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getCustomerCrudGetVersionQueryKey = (
  id: ModelsCustomerId,
  version: number
) => {
  return [`/api/v1/customers/${id}/versions/${version}`] as const
}

export const getCustomerCrudGetVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof customerCrudGetVersion>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  version: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetVersion>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getCustomerCrudGetVersionQueryKey(id, version)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof customerCrudGetVersion>>
  > = ({ signal }) =>
    customerCrudGetVersion(id, version, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!(id && version),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof customerCrudGetVersion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CustomerCrudGetVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof customerCrudGetVersion>>
>
export type CustomerCrudGetVersionQueryError = ModelsProblemDetails

export function useCustomerCrudGetVersion<
  TData = Awaited<ReturnType<typeof customerCrudGetVersion>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  version: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetVersion>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGetVersion>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGetVersion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGetVersion<
  TData = Awaited<ReturnType<typeof customerCrudGetVersion>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  version: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetVersion>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof customerCrudGetVersion>>,
          TError,
          Awaited<ReturnType<typeof customerCrudGetVersion>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCustomerCrudGetVersion<
  TData = Awaited<ReturnType<typeof customerCrudGetVersion>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  version: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetVersion>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get {Name} version
 */

export function useCustomerCrudGetVersion<
  TData = Awaited<ReturnType<typeof customerCrudGetVersion>>,
  TError = ModelsProblemDetails,
>(
  id: ModelsCustomerId,
  version: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof customerCrudGetVersion>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCustomerCrudGetVersionQueryOptions(
    id,
    version,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
