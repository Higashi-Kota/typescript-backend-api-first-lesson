/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * (title)
 * Comprehensive REST API for managing beauty salon operations including salons, staff, services, customers, reservations, bookings, treatments, payments, inventory, and access control. Built with TypeSpec for type-safe API-first development.
 * OpenAPI spec version: 0.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  BookingOperationsAddReservationBody,
  BookingOperationsCancelBody,
  BookingOperationsList200,
  BookingOperationsListParams,
  BookingOperationsProcessPayment200,
  BookingOperationsProcessPaymentBody,
  ModelsBooking,
  ModelsBookingDetail,
  ModelsBookingId,
  ModelsCreateBookingRequest,
  ModelsError,
  ModelsReservationId,
  ModelsUpdateBookingRequest,
} from '../../models'

import { customInstance } from '../../../../../io/src/libs/fetcher/fetcher'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary List bookings
 */
export type bookingOperationsListResponse200 = {
  data: BookingOperationsList200
  status: 200
}

export type bookingOperationsListResponseComposite =
  bookingOperationsListResponse200

export type bookingOperationsListResponse =
  bookingOperationsListResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsListUrl = (
  params?: BookingOperationsListParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/bookings?${stringifiedParams}`
    : `/api/v1/bookings`
}

export const bookingOperationsList = async (
  params?: BookingOperationsListParams,
  options?: RequestInit
): Promise<bookingOperationsListResponse> => {
  return customInstance<bookingOperationsListResponse>(
    getBookingOperationsListUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getBookingOperationsListQueryKey = (
  params?: BookingOperationsListParams
) => {
  return [`/api/v1/bookings`, ...(params ? [params] : [])] as const
}

export const getBookingOperationsListQueryOptions = <
  TData = Awaited<ReturnType<typeof bookingOperationsList>>,
  TError = unknown,
>(
  params?: BookingOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getBookingOperationsListQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof bookingOperationsList>>
  > = ({ signal }) =>
    bookingOperationsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof bookingOperationsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BookingOperationsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsList>>
>
export type BookingOperationsListQueryError = unknown

export function useBookingOperationsList<
  TData = Awaited<ReturnType<typeof bookingOperationsList>>,
  TError = unknown,
>(
  params: undefined | BookingOperationsListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingOperationsList>>,
          TError,
          Awaited<ReturnType<typeof bookingOperationsList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBookingOperationsList<
  TData = Awaited<ReturnType<typeof bookingOperationsList>>,
  TError = unknown,
>(
  params?: BookingOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingOperationsList>>,
          TError,
          Awaited<ReturnType<typeof bookingOperationsList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBookingOperationsList<
  TData = Awaited<ReturnType<typeof bookingOperationsList>>,
  TError = unknown,
>(
  params?: BookingOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List bookings
 */

export function useBookingOperationsList<
  TData = Awaited<ReturnType<typeof bookingOperationsList>>,
  TError = unknown,
>(
  params?: BookingOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getBookingOperationsListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create booking
 */
export type bookingOperationsCreateResponse201 = {
  data: ModelsBooking
  status: 201
}

export type bookingOperationsCreateResponse400 = {
  data: ModelsError
  status: 400
}

export type bookingOperationsCreateResponseComposite =
  | bookingOperationsCreateResponse201
  | bookingOperationsCreateResponse400

export type bookingOperationsCreateResponse =
  bookingOperationsCreateResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsCreateUrl = () => {
  return `/api/v1/bookings`
}

export const bookingOperationsCreate = async (
  modelsCreateBookingRequest: ModelsCreateBookingRequest,
  options?: RequestInit
): Promise<bookingOperationsCreateResponse> => {
  return customInstance<bookingOperationsCreateResponse>(
    getBookingOperationsCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsCreateBookingRequest),
    }
  )
}

export const getBookingOperationsCreateMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsCreate>>,
    TError,
    { data: ModelsCreateBookingRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsCreate>>,
  TError,
  { data: ModelsCreateBookingRequest },
  TContext
> => {
  const mutationKey = ['bookingOperationsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsCreate>>,
    { data: ModelsCreateBookingRequest }
  > = (props) => {
    const { data } = props ?? {}

    return bookingOperationsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsCreate>>
>
export type BookingOperationsCreateMutationBody = ModelsCreateBookingRequest
export type BookingOperationsCreateMutationError = ModelsError

/**
 * @summary Create booking
 */
export const useBookingOperationsCreate = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsCreate>>,
      TError,
      { data: ModelsCreateBookingRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsCreate>>,
  TError,
  { data: ModelsCreateBookingRequest },
  TContext
> => {
  const mutationOptions = getBookingOperationsCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get booking
 */
export type bookingOperationsGetResponse200 = {
  data: ModelsBookingDetail
  status: 200
}

export type bookingOperationsGetResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsGetResponseComposite =
  | bookingOperationsGetResponse200
  | bookingOperationsGetResponse404

export type bookingOperationsGetResponse =
  bookingOperationsGetResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsGetUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}`
}

export const bookingOperationsGet = async (
  id: ModelsBookingId,
  options?: RequestInit
): Promise<bookingOperationsGetResponse> => {
  return customInstance<bookingOperationsGetResponse>(
    getBookingOperationsGetUrl(id),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getBookingOperationsGetQueryKey = (id: ModelsBookingId) => {
  return [`/api/v1/bookings/${id}`] as const
}

export const getBookingOperationsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof bookingOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsBookingId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getBookingOperationsGetQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof bookingOperationsGet>>
  > = ({ signal }) => bookingOperationsGet(id, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof bookingOperationsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BookingOperationsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsGet>>
>
export type BookingOperationsGetQueryError = ModelsError

export function useBookingOperationsGet<
  TData = Awaited<ReturnType<typeof bookingOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsBookingId,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingOperationsGet>>,
          TError,
          Awaited<ReturnType<typeof bookingOperationsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBookingOperationsGet<
  TData = Awaited<ReturnType<typeof bookingOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsBookingId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingOperationsGet>>,
          TError,
          Awaited<ReturnType<typeof bookingOperationsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useBookingOperationsGet<
  TData = Awaited<ReturnType<typeof bookingOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsBookingId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get booking
 */

export function useBookingOperationsGet<
  TData = Awaited<ReturnType<typeof bookingOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsBookingId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof bookingOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getBookingOperationsGetQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update booking
 */
export type bookingOperationsUpdateResponse200 = {
  data: ModelsBooking
  status: 200
}

export type bookingOperationsUpdateResponse400 = {
  data: ModelsError
  status: 400
}

export type bookingOperationsUpdateResponseComposite =
  | bookingOperationsUpdateResponse200
  | bookingOperationsUpdateResponse400

export type bookingOperationsUpdateResponse =
  bookingOperationsUpdateResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsUpdateUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}`
}

export const bookingOperationsUpdate = async (
  id: ModelsBookingId,
  modelsUpdateBookingRequest: ModelsUpdateBookingRequest,
  options?: RequestInit
): Promise<bookingOperationsUpdateResponse> => {
  return customInstance<bookingOperationsUpdateResponse>(
    getBookingOperationsUpdateUrl(id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsUpdateBookingRequest),
    }
  )
}

export const getBookingOperationsUpdateMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsUpdate>>,
    TError,
    { id: ModelsBookingId; data: ModelsUpdateBookingRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsUpdate>>,
  TError,
  { id: ModelsBookingId; data: ModelsUpdateBookingRequest },
  TContext
> => {
  const mutationKey = ['bookingOperationsUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsUpdate>>,
    { id: ModelsBookingId; data: ModelsUpdateBookingRequest }
  > = (props) => {
    const { id, data } = props ?? {}

    return bookingOperationsUpdate(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsUpdate>>
>
export type BookingOperationsUpdateMutationBody = ModelsUpdateBookingRequest
export type BookingOperationsUpdateMutationError = ModelsError

/**
 * @summary Update booking
 */
export const useBookingOperationsUpdate = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsUpdate>>,
      TError,
      { id: ModelsBookingId; data: ModelsUpdateBookingRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsUpdate>>,
  TError,
  { id: ModelsBookingId; data: ModelsUpdateBookingRequest },
  TContext
> => {
  const mutationOptions = getBookingOperationsUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Delete booking
 */
export type bookingOperationsDeleteResponse204 = {
  data: void
  status: 204
}

export type bookingOperationsDeleteResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsDeleteResponseComposite =
  | bookingOperationsDeleteResponse204
  | bookingOperationsDeleteResponse404

export type bookingOperationsDeleteResponse =
  bookingOperationsDeleteResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsDeleteUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}`
}

export const bookingOperationsDelete = async (
  id: ModelsBookingId,
  options?: RequestInit
): Promise<bookingOperationsDeleteResponse> => {
  return customInstance<bookingOperationsDeleteResponse>(
    getBookingOperationsDeleteUrl(id),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

export const getBookingOperationsDeleteMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsDelete>>,
    TError,
    { id: ModelsBookingId },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsDelete>>,
  TError,
  { id: ModelsBookingId },
  TContext
> => {
  const mutationKey = ['bookingOperationsDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsDelete>>,
    { id: ModelsBookingId }
  > = (props) => {
    const { id } = props ?? {}

    return bookingOperationsDelete(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsDelete>>
>

export type BookingOperationsDeleteMutationError = ModelsError

/**
 * @summary Delete booking
 */
export const useBookingOperationsDelete = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsDelete>>,
      TError,
      { id: ModelsBookingId },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsDelete>>,
  TError,
  { id: ModelsBookingId },
  TContext
> => {
  const mutationOptions = getBookingOperationsDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Cancel booking
 */
export type bookingOperationsCancelResponse200 = {
  data: ModelsBooking
  status: 200
}

export type bookingOperationsCancelResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsCancelResponseComposite =
  | bookingOperationsCancelResponse200
  | bookingOperationsCancelResponse404

export type bookingOperationsCancelResponse =
  bookingOperationsCancelResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsCancelUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}/cancel`
}

export const bookingOperationsCancel = async (
  id: ModelsBookingId,
  bookingOperationsCancelBody: BookingOperationsCancelBody,
  options?: RequestInit
): Promise<bookingOperationsCancelResponse> => {
  return customInstance<bookingOperationsCancelResponse>(
    getBookingOperationsCancelUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingOperationsCancelBody),
    }
  )
}

export const getBookingOperationsCancelMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsCancel>>,
    TError,
    { id: ModelsBookingId; data: BookingOperationsCancelBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsCancel>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsCancelBody },
  TContext
> => {
  const mutationKey = ['bookingOperationsCancel']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsCancel>>,
    { id: ModelsBookingId; data: BookingOperationsCancelBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return bookingOperationsCancel(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsCancelMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsCancel>>
>
export type BookingOperationsCancelMutationBody = BookingOperationsCancelBody
export type BookingOperationsCancelMutationError = ModelsError

/**
 * @summary Cancel booking
 */
export const useBookingOperationsCancel = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsCancel>>,
      TError,
      { id: ModelsBookingId; data: BookingOperationsCancelBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsCancel>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsCancelBody },
  TContext
> => {
  const mutationOptions = getBookingOperationsCancelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Confirm booking
 */
export type bookingOperationsConfirmResponse200 = {
  data: ModelsBooking
  status: 200
}

export type bookingOperationsConfirmResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsConfirmResponseComposite =
  | bookingOperationsConfirmResponse200
  | bookingOperationsConfirmResponse404

export type bookingOperationsConfirmResponse =
  bookingOperationsConfirmResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsConfirmUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}/confirm`
}

export const bookingOperationsConfirm = async (
  id: ModelsBookingId,
  options?: RequestInit
): Promise<bookingOperationsConfirmResponse> => {
  return customInstance<bookingOperationsConfirmResponse>(
    getBookingOperationsConfirmUrl(id),
    {
      ...options,
      method: 'POST',
    }
  )
}

export const getBookingOperationsConfirmMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsConfirm>>,
    TError,
    { id: ModelsBookingId },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsConfirm>>,
  TError,
  { id: ModelsBookingId },
  TContext
> => {
  const mutationKey = ['bookingOperationsConfirm']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsConfirm>>,
    { id: ModelsBookingId }
  > = (props) => {
    const { id } = props ?? {}

    return bookingOperationsConfirm(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsConfirmMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsConfirm>>
>

export type BookingOperationsConfirmMutationError = ModelsError

/**
 * @summary Confirm booking
 */
export const useBookingOperationsConfirm = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsConfirm>>,
      TError,
      { id: ModelsBookingId },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsConfirm>>,
  TError,
  { id: ModelsBookingId },
  TContext
> => {
  const mutationOptions = getBookingOperationsConfirmMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Process payment
 */
export type bookingOperationsProcessPaymentResponse200 = {
  data: BookingOperationsProcessPayment200
  status: 200
}

export type bookingOperationsProcessPaymentResponse400 = {
  data: ModelsError
  status: 400
}

export type bookingOperationsProcessPaymentResponseComposite =
  | bookingOperationsProcessPaymentResponse200
  | bookingOperationsProcessPaymentResponse400

export type bookingOperationsProcessPaymentResponse =
  bookingOperationsProcessPaymentResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsProcessPaymentUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}/payment`
}

export const bookingOperationsProcessPayment = async (
  id: ModelsBookingId,
  bookingOperationsProcessPaymentBody: BookingOperationsProcessPaymentBody,
  options?: RequestInit
): Promise<bookingOperationsProcessPaymentResponse> => {
  return customInstance<bookingOperationsProcessPaymentResponse>(
    getBookingOperationsProcessPaymentUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingOperationsProcessPaymentBody),
    }
  )
}

export const getBookingOperationsProcessPaymentMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsProcessPayment>>,
    TError,
    { id: ModelsBookingId; data: BookingOperationsProcessPaymentBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsProcessPayment>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsProcessPaymentBody },
  TContext
> => {
  const mutationKey = ['bookingOperationsProcessPayment']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsProcessPayment>>,
    { id: ModelsBookingId; data: BookingOperationsProcessPaymentBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return bookingOperationsProcessPayment(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsProcessPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsProcessPayment>>
>
export type BookingOperationsProcessPaymentMutationBody =
  BookingOperationsProcessPaymentBody
export type BookingOperationsProcessPaymentMutationError = ModelsError

/**
 * @summary Process payment
 */
export const useBookingOperationsProcessPayment = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsProcessPayment>>,
      TError,
      { id: ModelsBookingId; data: BookingOperationsProcessPaymentBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsProcessPayment>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsProcessPaymentBody },
  TContext
> => {
  const mutationOptions =
    getBookingOperationsProcessPaymentMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Add reservation to booking
 */
export type bookingOperationsAddReservationResponse200 = {
  data: ModelsBooking
  status: 200
}

export type bookingOperationsAddReservationResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsAddReservationResponseComposite =
  | bookingOperationsAddReservationResponse200
  | bookingOperationsAddReservationResponse404

export type bookingOperationsAddReservationResponse =
  bookingOperationsAddReservationResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsAddReservationUrl = (id: ModelsBookingId) => {
  return `/api/v1/bookings/${id}/reservations`
}

export const bookingOperationsAddReservation = async (
  id: ModelsBookingId,
  bookingOperationsAddReservationBody: BookingOperationsAddReservationBody,
  options?: RequestInit
): Promise<bookingOperationsAddReservationResponse> => {
  return customInstance<bookingOperationsAddReservationResponse>(
    getBookingOperationsAddReservationUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingOperationsAddReservationBody),
    }
  )
}

export const getBookingOperationsAddReservationMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsAddReservation>>,
    TError,
    { id: ModelsBookingId; data: BookingOperationsAddReservationBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsAddReservation>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsAddReservationBody },
  TContext
> => {
  const mutationKey = ['bookingOperationsAddReservation']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsAddReservation>>,
    { id: ModelsBookingId; data: BookingOperationsAddReservationBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return bookingOperationsAddReservation(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsAddReservationMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsAddReservation>>
>
export type BookingOperationsAddReservationMutationBody =
  BookingOperationsAddReservationBody
export type BookingOperationsAddReservationMutationError = ModelsError

/**
 * @summary Add reservation to booking
 */
export const useBookingOperationsAddReservation = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsAddReservation>>,
      TError,
      { id: ModelsBookingId; data: BookingOperationsAddReservationBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsAddReservation>>,
  TError,
  { id: ModelsBookingId; data: BookingOperationsAddReservationBody },
  TContext
> => {
  const mutationOptions =
    getBookingOperationsAddReservationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Remove reservation from booking
 */
export type bookingOperationsRemoveReservationResponse200 = {
  data: ModelsBooking
  status: 200
}

export type bookingOperationsRemoveReservationResponse404 = {
  data: ModelsError
  status: 404
}

export type bookingOperationsRemoveReservationResponseComposite =
  | bookingOperationsRemoveReservationResponse200
  | bookingOperationsRemoveReservationResponse404

export type bookingOperationsRemoveReservationResponse =
  bookingOperationsRemoveReservationResponseComposite & {
    headers: Headers
  }

export const getBookingOperationsRemoveReservationUrl = (
  id: ModelsBookingId,
  reservationId: ModelsReservationId
) => {
  return `/api/v1/bookings/${id}/reservations/${reservationId}`
}

export const bookingOperationsRemoveReservation = async (
  id: ModelsBookingId,
  reservationId: ModelsReservationId,
  options?: RequestInit
): Promise<bookingOperationsRemoveReservationResponse> => {
  return customInstance<bookingOperationsRemoveReservationResponse>(
    getBookingOperationsRemoveReservationUrl(id, reservationId),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

export const getBookingOperationsRemoveReservationMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>,
    TError,
    { id: ModelsBookingId; reservationId: ModelsReservationId },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>,
  TError,
  { id: ModelsBookingId; reservationId: ModelsReservationId },
  TContext
> => {
  const mutationKey = ['bookingOperationsRemoveReservation']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>,
    { id: ModelsBookingId; reservationId: ModelsReservationId }
  > = (props) => {
    const { id, reservationId } = props ?? {}

    return bookingOperationsRemoveReservation(id, reservationId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BookingOperationsRemoveReservationMutationResult = NonNullable<
  Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>
>

export type BookingOperationsRemoveReservationMutationError = ModelsError

/**
 * @summary Remove reservation from booking
 */
export const useBookingOperationsRemoveReservation = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>,
      TError,
      { id: ModelsBookingId; reservationId: ModelsReservationId },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bookingOperationsRemoveReservation>>,
  TError,
  { id: ModelsBookingId; reservationId: ModelsReservationId },
  TContext
> => {
  const mutationOptions =
    getBookingOperationsRemoveReservationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
