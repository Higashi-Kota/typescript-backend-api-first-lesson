/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Beauty Salon API
 * Comprehensive REST API for managing beauty salon operations including salons, staff, services, customers, reservations, bookings, treatments, payments, inventory, and access control. Built with TypeSpec for type-safe API-first development.
 * OpenAPI spec version: 2.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AvailabilityOperationsCheckAvailability200,
  AvailabilityOperationsCheckAvailabilityBody,
  AvailabilityOperationsGetAvailableSlotsParams,
  ModelsAvailableSlot,
  ModelsCreateReservationRequest,
  ModelsError,
  ModelsReservation,
  ModelsReservationDetail,
  ModelsReservationId,
  ModelsSalonId,
  ModelsUpdateReservationRequest,
  ReservationOperationsCancelBody,
  ReservationOperationsList200,
  ReservationOperationsListParams,
  ReservationOperationsRescheduleBody,
} from '../../models'

import { customInstance } from '../../../../../io/src/libs/fetcher/fetcher'

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary List reservations
 */
export type reservationOperationsListResponse200 = {
  data: ReservationOperationsList200
  status: 200
}

export type reservationOperationsListResponseComposite =
  reservationOperationsListResponse200

export type reservationOperationsListResponse =
  reservationOperationsListResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsListUrl = (
  params?: ReservationOperationsListParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/reservations?${stringifiedParams}`
    : `/api/v1/reservations`
}

export const reservationOperationsList = async (
  params?: ReservationOperationsListParams,
  options?: RequestInit
): Promise<reservationOperationsListResponse> => {
  return customInstance<reservationOperationsListResponse>(
    getReservationOperationsListUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getReservationOperationsListQueryKey = (
  params?: ReservationOperationsListParams
) => {
  return [`/api/v1/reservations`, ...(params ? [params] : [])] as const
}

export const getReservationOperationsListQueryOptions = <
  TData = Awaited<ReturnType<typeof reservationOperationsList>>,
  TError = unknown,
>(
  params?: ReservationOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getReservationOperationsListQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reservationOperationsList>>
  > = ({ signal }) =>
    reservationOperationsList(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reservationOperationsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReservationOperationsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsList>>
>
export type ReservationOperationsListQueryError = unknown

export function useReservationOperationsList<
  TData = Awaited<ReturnType<typeof reservationOperationsList>>,
  TError = unknown,
>(
  params: undefined | ReservationOperationsListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reservationOperationsList>>,
          TError,
          Awaited<ReturnType<typeof reservationOperationsList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReservationOperationsList<
  TData = Awaited<ReturnType<typeof reservationOperationsList>>,
  TError = unknown,
>(
  params?: ReservationOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reservationOperationsList>>,
          TError,
          Awaited<ReturnType<typeof reservationOperationsList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReservationOperationsList<
  TData = Awaited<ReturnType<typeof reservationOperationsList>>,
  TError = unknown,
>(
  params?: ReservationOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List reservations
 */

export function useReservationOperationsList<
  TData = Awaited<ReturnType<typeof reservationOperationsList>>,
  TError = unknown,
>(
  params?: ReservationOperationsListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsList>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getReservationOperationsListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create reservation
 */
export type reservationOperationsCreateResponse201 = {
  data: ModelsReservation
  status: 201
}

export type reservationOperationsCreateResponse400 = {
  data: ModelsError
  status: 400
}

export type reservationOperationsCreateResponseComposite =
  | reservationOperationsCreateResponse201
  | reservationOperationsCreateResponse400

export type reservationOperationsCreateResponse =
  reservationOperationsCreateResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsCreateUrl = () => {
  return `/api/v1/reservations`
}

export const reservationOperationsCreate = async (
  modelsCreateReservationRequest: ModelsCreateReservationRequest,
  options?: RequestInit
): Promise<reservationOperationsCreateResponse> => {
  return customInstance<reservationOperationsCreateResponse>(
    getReservationOperationsCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsCreateReservationRequest),
    }
  )
}

export const getReservationOperationsCreateMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reservationOperationsCreate>>,
    TError,
    { data: ModelsCreateReservationRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof reservationOperationsCreate>>,
  TError,
  { data: ModelsCreateReservationRequest },
  TContext
> => {
  const mutationKey = ['reservationOperationsCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reservationOperationsCreate>>,
    { data: ModelsCreateReservationRequest }
  > = (props) => {
    const { data } = props ?? {}

    return reservationOperationsCreate(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ReservationOperationsCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsCreate>>
>
export type ReservationOperationsCreateMutationBody =
  ModelsCreateReservationRequest
export type ReservationOperationsCreateMutationError = ModelsError

/**
 * @summary Create reservation
 */
export const useReservationOperationsCreate = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reservationOperationsCreate>>,
      TError,
      { data: ModelsCreateReservationRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reservationOperationsCreate>>,
  TError,
  { data: ModelsCreateReservationRequest },
  TContext
> => {
  const mutationOptions = getReservationOperationsCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get reservation
 */
export type reservationOperationsGetResponse200 = {
  data: ModelsReservationDetail
  status: 200
}

export type reservationOperationsGetResponse404 = {
  data: ModelsError
  status: 404
}

export type reservationOperationsGetResponseComposite =
  | reservationOperationsGetResponse200
  | reservationOperationsGetResponse404

export type reservationOperationsGetResponse =
  reservationOperationsGetResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsGetUrl = (id: ModelsReservationId) => {
  return `/api/v1/reservations/${id}`
}

export const reservationOperationsGet = async (
  id: ModelsReservationId,
  options?: RequestInit
): Promise<reservationOperationsGetResponse> => {
  return customInstance<reservationOperationsGetResponse>(
    getReservationOperationsGetUrl(id),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getReservationOperationsGetQueryKey = (
  id: ModelsReservationId
) => {
  return [`/api/v1/reservations/${id}`] as const
}

export const getReservationOperationsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof reservationOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsReservationId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getReservationOperationsGetQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reservationOperationsGet>>
  > = ({ signal }) =>
    reservationOperationsGet(id, { signal, ...requestOptions })

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof reservationOperationsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReservationOperationsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsGet>>
>
export type ReservationOperationsGetQueryError = ModelsError

export function useReservationOperationsGet<
  TData = Awaited<ReturnType<typeof reservationOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsReservationId,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reservationOperationsGet>>,
          TError,
          Awaited<ReturnType<typeof reservationOperationsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReservationOperationsGet<
  TData = Awaited<ReturnType<typeof reservationOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsReservationId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reservationOperationsGet>>,
          TError,
          Awaited<ReturnType<typeof reservationOperationsGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReservationOperationsGet<
  TData = Awaited<ReturnType<typeof reservationOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsReservationId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get reservation
 */

export function useReservationOperationsGet<
  TData = Awaited<ReturnType<typeof reservationOperationsGet>>,
  TError = ModelsError,
>(
  id: ModelsReservationId,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reservationOperationsGet>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getReservationOperationsGetQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update reservation
 */
export type reservationOperationsUpdateResponse200 = {
  data: ModelsReservation
  status: 200
}

export type reservationOperationsUpdateResponse400 = {
  data: ModelsError
  status: 400
}

export type reservationOperationsUpdateResponseComposite =
  | reservationOperationsUpdateResponse200
  | reservationOperationsUpdateResponse400

export type reservationOperationsUpdateResponse =
  reservationOperationsUpdateResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsUpdateUrl = (id: ModelsReservationId) => {
  return `/api/v1/reservations/${id}`
}

export const reservationOperationsUpdate = async (
  id: ModelsReservationId,
  modelsUpdateReservationRequest: ModelsUpdateReservationRequest,
  options?: RequestInit
): Promise<reservationOperationsUpdateResponse> => {
  return customInstance<reservationOperationsUpdateResponse>(
    getReservationOperationsUpdateUrl(id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(modelsUpdateReservationRequest),
    }
  )
}

export const getReservationOperationsUpdateMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reservationOperationsUpdate>>,
    TError,
    { id: ModelsReservationId; data: ModelsUpdateReservationRequest },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof reservationOperationsUpdate>>,
  TError,
  { id: ModelsReservationId; data: ModelsUpdateReservationRequest },
  TContext
> => {
  const mutationKey = ['reservationOperationsUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reservationOperationsUpdate>>,
    { id: ModelsReservationId; data: ModelsUpdateReservationRequest }
  > = (props) => {
    const { id, data } = props ?? {}

    return reservationOperationsUpdate(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ReservationOperationsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsUpdate>>
>
export type ReservationOperationsUpdateMutationBody =
  ModelsUpdateReservationRequest
export type ReservationOperationsUpdateMutationError = ModelsError

/**
 * @summary Update reservation
 */
export const useReservationOperationsUpdate = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reservationOperationsUpdate>>,
      TError,
      { id: ModelsReservationId; data: ModelsUpdateReservationRequest },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reservationOperationsUpdate>>,
  TError,
  { id: ModelsReservationId; data: ModelsUpdateReservationRequest },
  TContext
> => {
  const mutationOptions = getReservationOperationsUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Cancel reservation
 */
export type reservationOperationsCancelResponse200 = {
  data: ModelsReservation
  status: 200
}

export type reservationOperationsCancelResponse404 = {
  data: ModelsError
  status: 404
}

export type reservationOperationsCancelResponseComposite =
  | reservationOperationsCancelResponse200
  | reservationOperationsCancelResponse404

export type reservationOperationsCancelResponse =
  reservationOperationsCancelResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsCancelUrl = (id: ModelsReservationId) => {
  return `/api/v1/reservations/${id}/cancel`
}

export const reservationOperationsCancel = async (
  id: ModelsReservationId,
  reservationOperationsCancelBody: ReservationOperationsCancelBody,
  options?: RequestInit
): Promise<reservationOperationsCancelResponse> => {
  return customInstance<reservationOperationsCancelResponse>(
    getReservationOperationsCancelUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(reservationOperationsCancelBody),
    }
  )
}

export const getReservationOperationsCancelMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reservationOperationsCancel>>,
    TError,
    { id: ModelsReservationId; data: ReservationOperationsCancelBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof reservationOperationsCancel>>,
  TError,
  { id: ModelsReservationId; data: ReservationOperationsCancelBody },
  TContext
> => {
  const mutationKey = ['reservationOperationsCancel']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reservationOperationsCancel>>,
    { id: ModelsReservationId; data: ReservationOperationsCancelBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return reservationOperationsCancel(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ReservationOperationsCancelMutationResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsCancel>>
>
export type ReservationOperationsCancelMutationBody =
  ReservationOperationsCancelBody
export type ReservationOperationsCancelMutationError = ModelsError

/**
 * @summary Cancel reservation
 */
export const useReservationOperationsCancel = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reservationOperationsCancel>>,
      TError,
      { id: ModelsReservationId; data: ReservationOperationsCancelBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reservationOperationsCancel>>,
  TError,
  { id: ModelsReservationId; data: ReservationOperationsCancelBody },
  TContext
> => {
  const mutationOptions = getReservationOperationsCancelMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Complete reservation
 */
export type reservationOperationsCompleteResponse200 = {
  data: ModelsReservation
  status: 200
}

export type reservationOperationsCompleteResponse404 = {
  data: ModelsError
  status: 404
}

export type reservationOperationsCompleteResponseComposite =
  | reservationOperationsCompleteResponse200
  | reservationOperationsCompleteResponse404

export type reservationOperationsCompleteResponse =
  reservationOperationsCompleteResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsCompleteUrl = (
  id: ModelsReservationId
) => {
  return `/api/v1/reservations/${id}/complete`
}

export const reservationOperationsComplete = async (
  id: ModelsReservationId,
  options?: RequestInit
): Promise<reservationOperationsCompleteResponse> => {
  return customInstance<reservationOperationsCompleteResponse>(
    getReservationOperationsCompleteUrl(id),
    {
      ...options,
      method: 'POST',
    }
  )
}

export const getReservationOperationsCompleteMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reservationOperationsComplete>>,
    TError,
    { id: ModelsReservationId },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof reservationOperationsComplete>>,
  TError,
  { id: ModelsReservationId },
  TContext
> => {
  const mutationKey = ['reservationOperationsComplete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reservationOperationsComplete>>,
    { id: ModelsReservationId }
  > = (props) => {
    const { id } = props ?? {}

    return reservationOperationsComplete(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ReservationOperationsCompleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsComplete>>
>

export type ReservationOperationsCompleteMutationError = ModelsError

/**
 * @summary Complete reservation
 */
export const useReservationOperationsComplete = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reservationOperationsComplete>>,
      TError,
      { id: ModelsReservationId },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reservationOperationsComplete>>,
  TError,
  { id: ModelsReservationId },
  TContext
> => {
  const mutationOptions =
    getReservationOperationsCompleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Reschedule reservation
 */
export type reservationOperationsRescheduleResponse200 = {
  data: ModelsReservation
  status: 200
}

export type reservationOperationsRescheduleResponse404 = {
  data: ModelsError
  status: 404
}

export type reservationOperationsRescheduleResponseComposite =
  | reservationOperationsRescheduleResponse200
  | reservationOperationsRescheduleResponse404

export type reservationOperationsRescheduleResponse =
  reservationOperationsRescheduleResponseComposite & {
    headers: Headers
  }

export const getReservationOperationsRescheduleUrl = (
  id: ModelsReservationId
) => {
  return `/api/v1/reservations/${id}/reschedule`
}

export const reservationOperationsReschedule = async (
  id: ModelsReservationId,
  reservationOperationsRescheduleBody: ReservationOperationsRescheduleBody,
  options?: RequestInit
): Promise<reservationOperationsRescheduleResponse> => {
  return customInstance<reservationOperationsRescheduleResponse>(
    getReservationOperationsRescheduleUrl(id),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(reservationOperationsRescheduleBody),
    }
  )
}

export const getReservationOperationsRescheduleMutationOptions = <
  TError = ModelsError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reservationOperationsReschedule>>,
    TError,
    { id: ModelsReservationId; data: ReservationOperationsRescheduleBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof reservationOperationsReschedule>>,
  TError,
  { id: ModelsReservationId; data: ReservationOperationsRescheduleBody },
  TContext
> => {
  const mutationKey = ['reservationOperationsReschedule']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reservationOperationsReschedule>>,
    { id: ModelsReservationId; data: ReservationOperationsRescheduleBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return reservationOperationsReschedule(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ReservationOperationsRescheduleMutationResult = NonNullable<
  Awaited<ReturnType<typeof reservationOperationsReschedule>>
>
export type ReservationOperationsRescheduleMutationBody =
  ReservationOperationsRescheduleBody
export type ReservationOperationsRescheduleMutationError = ModelsError

/**
 * @summary Reschedule reservation
 */
export const useReservationOperationsReschedule = <
  TError = ModelsError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reservationOperationsReschedule>>,
      TError,
      { id: ModelsReservationId; data: ReservationOperationsRescheduleBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reservationOperationsReschedule>>,
  TError,
  { id: ModelsReservationId; data: ReservationOperationsRescheduleBody },
  TContext
> => {
  const mutationOptions =
    getReservationOperationsRescheduleMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get available slots
 */
export type availabilityOperationsGetAvailableSlotsResponse200 = {
  data: ModelsAvailableSlot[]
  status: 200
}

export type availabilityOperationsGetAvailableSlotsResponse400 = {
  data: ModelsError
  status: 400
}

export type availabilityOperationsGetAvailableSlotsResponseComposite =
  | availabilityOperationsGetAvailableSlotsResponse200
  | availabilityOperationsGetAvailableSlotsResponse400

export type availabilityOperationsGetAvailableSlotsResponse =
  availabilityOperationsGetAvailableSlotsResponseComposite & {
    headers: Headers
  }

export const getAvailabilityOperationsGetAvailableSlotsUrl = (
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/salons/${salonId}/available-slots?${stringifiedParams}`
    : `/api/v1/salons/${salonId}/available-slots`
}

export const availabilityOperationsGetAvailableSlots = async (
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options?: RequestInit
): Promise<availabilityOperationsGetAvailableSlotsResponse> => {
  return customInstance<availabilityOperationsGetAvailableSlotsResponse>(
    getAvailabilityOperationsGetAvailableSlotsUrl(salonId, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getAvailabilityOperationsGetAvailableSlotsQueryKey = (
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams
) => {
  return [
    `/api/v1/salons/${salonId}/available-slots`,
    ...(params ? [params] : []),
  ] as const
}

export const getAvailabilityOperationsGetAvailableSlotsQueryOptions = <
  TData = Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
  TError = ModelsError,
>(
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getAvailabilityOperationsGetAvailableSlotsQueryKey(salonId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>
  > = ({ signal }) =>
    availabilityOperationsGetAvailableSlots(salonId, params, {
      signal,
      ...requestOptions,
    })

  return {
    queryKey,
    queryFn,
    enabled: !!salonId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AvailabilityOperationsGetAvailableSlotsQueryResult = NonNullable<
  Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>
>
export type AvailabilityOperationsGetAvailableSlotsQueryError = ModelsError

export function useAvailabilityOperationsGetAvailableSlots<
  TData = Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
  TError = ModelsError,
>(
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
          TError,
          Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAvailabilityOperationsGetAvailableSlots<
  TData = Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
  TError = ModelsError,
>(
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
          TError,
          Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAvailabilityOperationsGetAvailableSlots<
  TData = Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
  TError = ModelsError,
>(
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get available slots
 */

export function useAvailabilityOperationsGetAvailableSlots<
  TData = Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
  TError = ModelsError,
>(
  salonId: ModelsSalonId,
  params: AvailabilityOperationsGetAvailableSlotsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof availabilityOperationsGetAvailableSlots>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAvailabilityOperationsGetAvailableSlotsQueryOptions(
    salonId,
    params,
    options
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Check availability
 */
export type availabilityOperationsCheckAvailabilityResponse200 = {
  data: AvailabilityOperationsCheckAvailability200
  status: 200
}

export type availabilityOperationsCheckAvailabilityResponseComposite =
  availabilityOperationsCheckAvailabilityResponse200

export type availabilityOperationsCheckAvailabilityResponse =
  availabilityOperationsCheckAvailabilityResponseComposite & {
    headers: Headers
  }

export const getAvailabilityOperationsCheckAvailabilityUrl = (
  salonId: ModelsSalonId
) => {
  return `/api/v1/salons/${salonId}/available-slots/check`
}

export const availabilityOperationsCheckAvailability = async (
  salonId: ModelsSalonId,
  availabilityOperationsCheckAvailabilityBody: AvailabilityOperationsCheckAvailabilityBody,
  options?: RequestInit
): Promise<availabilityOperationsCheckAvailabilityResponse> => {
  return customInstance<availabilityOperationsCheckAvailabilityResponse>(
    getAvailabilityOperationsCheckAvailabilityUrl(salonId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(availabilityOperationsCheckAvailabilityBody),
    }
  )
}

export const getAvailabilityOperationsCheckAvailabilityMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>,
    TError,
    {
      salonId: ModelsSalonId
      data: AvailabilityOperationsCheckAvailabilityBody
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>,
  TError,
  { salonId: ModelsSalonId; data: AvailabilityOperationsCheckAvailabilityBody },
  TContext
> => {
  const mutationKey = ['availabilityOperationsCheckAvailability']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>,
    {
      salonId: ModelsSalonId
      data: AvailabilityOperationsCheckAvailabilityBody
    }
  > = (props) => {
    const { salonId, data } = props ?? {}

    return availabilityOperationsCheckAvailability(
      salonId,
      data,
      requestOptions
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type AvailabilityOperationsCheckAvailabilityMutationResult = NonNullable<
  Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>
>
export type AvailabilityOperationsCheckAvailabilityMutationBody =
  AvailabilityOperationsCheckAvailabilityBody
export type AvailabilityOperationsCheckAvailabilityMutationError = unknown

/**
 * @summary Check availability
 */
export const useAvailabilityOperationsCheckAvailability = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>,
      TError,
      {
        salonId: ModelsSalonId
        data: AvailabilityOperationsCheckAvailabilityBody
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof availabilityOperationsCheckAvailability>>,
  TError,
  { salonId: ModelsSalonId; data: AvailabilityOperationsCheckAvailabilityBody },
  TContext
> => {
  const mutationOptions =
    getAvailabilityOperationsCheckAvailabilityMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
